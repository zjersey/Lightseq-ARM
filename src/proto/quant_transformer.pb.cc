// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: quant_transformer.proto

#include "quant_transformer.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR QuantEncoderLayer::QuantEncoderLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.multihead_norm_scale_)*/{}
  , /*decltype(_impl_.multihead_norm_bias_)*/{}
  , /*decltype(_impl_.multihead_project_bias_qkv_)*/{}
  , /*decltype(_impl_.multihead_project_bias_output_)*/{}
  , /*decltype(_impl_.ffn_norm_scale_)*/{}
  , /*decltype(_impl_.ffn_norm_bias_)*/{}
  , /*decltype(_impl_.ffn_first_bias_)*/{}
  , /*decltype(_impl_.ffn_second_bias_)*/{}
  , /*decltype(_impl_.multihead_project_kernel_qkv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.multihead_project_kernel_output_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ffn_first_kernel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ffn_second_kernel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.multihead_project_kernel_qkv_clip_max_)*/0
  , /*decltype(_impl_.multihead_project_kernel_output_clip_max_)*/0
  , /*decltype(_impl_.ffn_first_kernel_clip_max_)*/0
  , /*decltype(_impl_.ffn_second_kernel_clip_max_)*/0
  , /*decltype(_impl_.multihead_ln_clip_max_)*/0
  , /*decltype(_impl_.multihead_project_output_clip_max_)*/0
  , /*decltype(_impl_.ffn_ln_clip_max_)*/0
  , /*decltype(_impl_.ffn_first_act_clip_max_)*/0
  , /*decltype(_impl_.multihead_qkv_dense_clip_max_)*/0
  , /*decltype(_impl_.multihead_output_dense_clip_max_)*/0
  , /*decltype(_impl_.ffn_first_output_clip_max_)*/0
  , /*decltype(_impl_.ffn_second_output_clip_max_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuantEncoderLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuantEncoderLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuantEncoderLayerDefaultTypeInternal() {}
  union {
    QuantEncoderLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuantEncoderLayerDefaultTypeInternal _QuantEncoderLayer_default_instance_;
PROTOBUF_CONSTEXPR QuantDecoderLayer::QuantDecoderLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.self_norm_scale_)*/{}
  , /*decltype(_impl_.self_norm_bias_)*/{}
  , /*decltype(_impl_.self_project_bias_qkv_)*/{}
  , /*decltype(_impl_.self_project_bias_output_)*/{}
  , /*decltype(_impl_.encdec_norm_scale_)*/{}
  , /*decltype(_impl_.encdec_norm_bias_)*/{}
  , /*decltype(_impl_.encdec_project_bias_q_)*/{}
  , /*decltype(_impl_.encdec_project_bias_output_)*/{}
  , /*decltype(_impl_.ffn_norm_scale_)*/{}
  , /*decltype(_impl_.ffn_norm_bias_)*/{}
  , /*decltype(_impl_.ffn_first_bias_)*/{}
  , /*decltype(_impl_.ffn_second_bias_)*/{}
  , /*decltype(_impl_.self_project_kernel_qkv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.self_project_kernel_output_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encdec_project_kernel_q_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encdec_project_kernel_output_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ffn_first_kernel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ffn_second_kernel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.self_project_kernel_qkv_clip_max_)*/0
  , /*decltype(_impl_.self_project_kernel_output_clip_max_)*/0
  , /*decltype(_impl_.encdec_project_kernel_q_clip_max_)*/0
  , /*decltype(_impl_.encdec_project_kernel_output_clip_max_)*/0
  , /*decltype(_impl_.ffn_first_kernel_clip_max_)*/0
  , /*decltype(_impl_.ffn_second_kernel_clip_max_)*/0
  , /*decltype(_impl_.self_ln_clip_max_)*/0
  , /*decltype(_impl_.self_project_output_clip_max_)*/0
  , /*decltype(_impl_.encdec_ln_clip_max_)*/0
  , /*decltype(_impl_.encdec_project_output_clip_max_)*/0
  , /*decltype(_impl_.ffn_ln_clip_max_)*/0
  , /*decltype(_impl_.ffn_first_act_clip_max_)*/0
  , /*decltype(_impl_.self_qkv_dense_clip_max_)*/0
  , /*decltype(_impl_.self_output_dense_clip_max_)*/0
  , /*decltype(_impl_.encdec_q_dense_clip_max_)*/0
  , /*decltype(_impl_.encdec_output_dense_clip_max_)*/0
  , /*decltype(_impl_.ffn_first_output_clip_max_)*/0
  , /*decltype(_impl_.ffn_second_output_clip_max_)*/0
  , /*decltype(_impl_.self_qkv_bias_out_clip_max_)*/0
  , /*decltype(_impl_.encdec_q_bias_out_clip_max_)*/0
  , /*decltype(_impl_.encdec_kv_bias_out_clip_max_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuantDecoderLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuantDecoderLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuantDecoderLayerDefaultTypeInternal() {}
  union {
    QuantDecoderLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuantDecoderLayerDefaultTypeInternal _QuantDecoderLayer_default_instance_;
PROTOBUF_CONSTEXPR QuantEmbeddingLayer::QuantEmbeddingLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_embedding_)*/{}
  , /*decltype(_impl_.norm_scale_)*/{}
  , /*decltype(_impl_.norm_bias_)*/{}
  , /*decltype(_impl_.encode_output_project_bias_kv_)*/{}
  , /*decltype(_impl_.shared_bias_)*/{}
  , /*decltype(_impl_.lang_emb_)*/{}
  , /*decltype(_impl_.encode_output_project_kernel_kv_clip_max_)*/{}
  , /*decltype(_impl_.token_embedding_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encode_output_project_kernel_kv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.emb_clip_max_)*/0
  , /*decltype(_impl_.output_ln_clip_max_)*/0
  , /*decltype(_impl_.logits_clip_max_)*/0
  , /*decltype(_impl_.encoder_output_clip_max_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuantEmbeddingLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuantEmbeddingLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuantEmbeddingLayerDefaultTypeInternal() {}
  union {
    QuantEmbeddingLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuantEmbeddingLayerDefaultTypeInternal _QuantEmbeddingLayer_default_instance_;
PROTOBUF_CONSTEXPR QuantModelConf::QuantModelConf(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sampling_method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.head_num_)*/0
  , /*decltype(_impl_.beam_size_)*/0
  , /*decltype(_impl_.extra_decode_length_)*/0
  , /*decltype(_impl_.length_penalty_)*/0
  , /*decltype(_impl_.src_padding_id_)*/0
  , /*decltype(_impl_.trg_start_id_)*/0
  , /*decltype(_impl_.diverse_lambda_)*/0
  , /*decltype(_impl_.topp_)*/0
  , /*decltype(_impl_.topk_)*/0
  , /*decltype(_impl_.trg_end_id_)*/0
  , /*decltype(_impl_.is_post_ln_)*/false
  , /*decltype(_impl_.no_scale_embedding_)*/false
  , /*decltype(_impl_.use_gelu_)*/false
  , /*decltype(_impl_.multilg_type_)*/0
  , /*decltype(_impl_.n_encoder_stack_)*/0
  , /*decltype(_impl_.n_decoder_stack_)*/0
  , /*decltype(_impl_.greedy_len_a_)*/0
  , /*decltype(_impl_.greedy_len_b_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuantModelConfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuantModelConfDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuantModelConfDefaultTypeInternal() {}
  union {
    QuantModelConf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuantModelConfDefaultTypeInternal _QuantModelConf_default_instance_;
PROTOBUF_CONSTEXPR QuantTransformer::QuantTransformer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.encoder_stack_)*/{}
  , /*decltype(_impl_.decoder_stack_)*/{}
  , /*decltype(_impl_.src_embedding_)*/nullptr
  , /*decltype(_impl_.trg_embedding_)*/nullptr
  , /*decltype(_impl_.model_conf_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuantTransformerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuantTransformerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuantTransformerDefaultTypeInternal() {}
  union {
    QuantTransformer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuantTransformerDefaultTypeInternal _QuantTransformer_default_instance_;

// ===================================================================

class QuantEncoderLayer::_Internal {
 public:
};

QuantEncoderLayer::QuantEncoderLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:QuantEncoderLayer)
}
QuantEncoderLayer::QuantEncoderLayer(const QuantEncoderLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  QuantEncoderLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.multihead_norm_scale_){from._impl_.multihead_norm_scale_}
    , decltype(_impl_.multihead_norm_bias_){from._impl_.multihead_norm_bias_}
    , decltype(_impl_.multihead_project_bias_qkv_){from._impl_.multihead_project_bias_qkv_}
    , decltype(_impl_.multihead_project_bias_output_){from._impl_.multihead_project_bias_output_}
    , decltype(_impl_.ffn_norm_scale_){from._impl_.ffn_norm_scale_}
    , decltype(_impl_.ffn_norm_bias_){from._impl_.ffn_norm_bias_}
    , decltype(_impl_.ffn_first_bias_){from._impl_.ffn_first_bias_}
    , decltype(_impl_.ffn_second_bias_){from._impl_.ffn_second_bias_}
    , decltype(_impl_.multihead_project_kernel_qkv_){}
    , decltype(_impl_.multihead_project_kernel_output_){}
    , decltype(_impl_.ffn_first_kernel_){}
    , decltype(_impl_.ffn_second_kernel_){}
    , decltype(_impl_.multihead_project_kernel_qkv_clip_max_){}
    , decltype(_impl_.multihead_project_kernel_output_clip_max_){}
    , decltype(_impl_.ffn_first_kernel_clip_max_){}
    , decltype(_impl_.ffn_second_kernel_clip_max_){}
    , decltype(_impl_.multihead_ln_clip_max_){}
    , decltype(_impl_.multihead_project_output_clip_max_){}
    , decltype(_impl_.ffn_ln_clip_max_){}
    , decltype(_impl_.ffn_first_act_clip_max_){}
    , decltype(_impl_.multihead_qkv_dense_clip_max_){}
    , decltype(_impl_.multihead_output_dense_clip_max_){}
    , decltype(_impl_.ffn_first_output_clip_max_){}
    , decltype(_impl_.ffn_second_output_clip_max_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.multihead_project_kernel_qkv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.multihead_project_kernel_qkv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_multihead_project_kernel_qkv().empty()) {
    _this->_impl_.multihead_project_kernel_qkv_.Set(from._internal_multihead_project_kernel_qkv(), 
      _this->GetArenaForAllocation());
  }
  _impl_.multihead_project_kernel_output_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.multihead_project_kernel_output_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_multihead_project_kernel_output().empty()) {
    _this->_impl_.multihead_project_kernel_output_.Set(from._internal_multihead_project_kernel_output(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ffn_first_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_first_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ffn_first_kernel().empty()) {
    _this->_impl_.ffn_first_kernel_.Set(from._internal_ffn_first_kernel(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ffn_second_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_second_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ffn_second_kernel().empty()) {
    _this->_impl_.ffn_second_kernel_.Set(from._internal_ffn_second_kernel(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.multihead_project_kernel_qkv_clip_max_, &from._impl_.multihead_project_kernel_qkv_clip_max_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ffn_second_output_clip_max_) -
    reinterpret_cast<char*>(&_impl_.multihead_project_kernel_qkv_clip_max_)) + sizeof(_impl_.ffn_second_output_clip_max_));
  // @@protoc_insertion_point(copy_constructor:QuantEncoderLayer)
}

inline void QuantEncoderLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.multihead_norm_scale_){arena}
    , decltype(_impl_.multihead_norm_bias_){arena}
    , decltype(_impl_.multihead_project_bias_qkv_){arena}
    , decltype(_impl_.multihead_project_bias_output_){arena}
    , decltype(_impl_.ffn_norm_scale_){arena}
    , decltype(_impl_.ffn_norm_bias_){arena}
    , decltype(_impl_.ffn_first_bias_){arena}
    , decltype(_impl_.ffn_second_bias_){arena}
    , decltype(_impl_.multihead_project_kernel_qkv_){}
    , decltype(_impl_.multihead_project_kernel_output_){}
    , decltype(_impl_.ffn_first_kernel_){}
    , decltype(_impl_.ffn_second_kernel_){}
    , decltype(_impl_.multihead_project_kernel_qkv_clip_max_){0}
    , decltype(_impl_.multihead_project_kernel_output_clip_max_){0}
    , decltype(_impl_.ffn_first_kernel_clip_max_){0}
    , decltype(_impl_.ffn_second_kernel_clip_max_){0}
    , decltype(_impl_.multihead_ln_clip_max_){0}
    , decltype(_impl_.multihead_project_output_clip_max_){0}
    , decltype(_impl_.ffn_ln_clip_max_){0}
    , decltype(_impl_.ffn_first_act_clip_max_){0}
    , decltype(_impl_.multihead_qkv_dense_clip_max_){0}
    , decltype(_impl_.multihead_output_dense_clip_max_){0}
    , decltype(_impl_.ffn_first_output_clip_max_){0}
    , decltype(_impl_.ffn_second_output_clip_max_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.multihead_project_kernel_qkv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.multihead_project_kernel_qkv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.multihead_project_kernel_output_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.multihead_project_kernel_output_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ffn_first_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_first_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ffn_second_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_second_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuantEncoderLayer::~QuantEncoderLayer() {
  // @@protoc_insertion_point(destructor:QuantEncoderLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuantEncoderLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.multihead_norm_scale_.~RepeatedField();
  _impl_.multihead_norm_bias_.~RepeatedField();
  _impl_.multihead_project_bias_qkv_.~RepeatedField();
  _impl_.multihead_project_bias_output_.~RepeatedField();
  _impl_.ffn_norm_scale_.~RepeatedField();
  _impl_.ffn_norm_bias_.~RepeatedField();
  _impl_.ffn_first_bias_.~RepeatedField();
  _impl_.ffn_second_bias_.~RepeatedField();
  _impl_.multihead_project_kernel_qkv_.Destroy();
  _impl_.multihead_project_kernel_output_.Destroy();
  _impl_.ffn_first_kernel_.Destroy();
  _impl_.ffn_second_kernel_.Destroy();
}

void QuantEncoderLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuantEncoderLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:QuantEncoderLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.multihead_norm_scale_.Clear();
  _impl_.multihead_norm_bias_.Clear();
  _impl_.multihead_project_bias_qkv_.Clear();
  _impl_.multihead_project_bias_output_.Clear();
  _impl_.ffn_norm_scale_.Clear();
  _impl_.ffn_norm_bias_.Clear();
  _impl_.ffn_first_bias_.Clear();
  _impl_.ffn_second_bias_.Clear();
  _impl_.multihead_project_kernel_qkv_.ClearToEmpty();
  _impl_.multihead_project_kernel_output_.ClearToEmpty();
  _impl_.ffn_first_kernel_.ClearToEmpty();
  _impl_.ffn_second_kernel_.ClearToEmpty();
  ::memset(&_impl_.multihead_project_kernel_qkv_clip_max_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ffn_second_output_clip_max_) -
      reinterpret_cast<char*>(&_impl_.multihead_project_kernel_qkv_clip_max_)) + sizeof(_impl_.ffn_second_output_clip_max_));
  _internal_metadata_.Clear<std::string>();
}

const char* QuantEncoderLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float multihead_norm_scale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_multihead_norm_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_multihead_norm_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float multihead_norm_bias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_multihead_norm_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_multihead_norm_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes multihead_project_kernel_qkv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_multihead_project_kernel_qkv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float multihead_project_bias_qkv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_multihead_project_bias_qkv(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 37) {
          _internal_add_multihead_project_bias_qkv(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes multihead_project_kernel_output = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_multihead_project_kernel_output();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float multihead_project_bias_output = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_multihead_project_bias_output(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 53) {
          _internal_add_multihead_project_bias_output(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_norm_scale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_norm_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 61) {
          _internal_add_ffn_norm_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_norm_bias = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_norm_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 69) {
          _internal_add_ffn_norm_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes ffn_first_kernel = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_ffn_first_kernel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_first_bias = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_first_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 85) {
          _internal_add_ffn_first_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes ffn_second_kernel = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_ffn_second_kernel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_second_bias = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_second_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 101) {
          _internal_add_ffn_second_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float multihead_project_kernel_qkv_clip_max = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _impl_.multihead_project_kernel_qkv_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float multihead_project_kernel_output_clip_max = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _impl_.multihead_project_kernel_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_first_kernel_clip_max = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _impl_.ffn_first_kernel_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_second_kernel_clip_max = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _impl_.ffn_second_kernel_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float multihead_ln_clip_max = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _impl_.multihead_ln_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float multihead_project_output_clip_max = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _impl_.multihead_project_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_ln_clip_max = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _impl_.ffn_ln_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_first_act_clip_max = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _impl_.ffn_first_act_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float multihead_qkv_dense_clip_max = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _impl_.multihead_qkv_dense_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float multihead_output_dense_clip_max = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _impl_.multihead_output_dense_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_first_output_clip_max = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          _impl_.ffn_first_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_second_output_clip_max = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _impl_.ffn_second_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuantEncoderLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:QuantEncoderLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float multihead_norm_scale = 1;
  if (this->_internal_multihead_norm_scale_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_multihead_norm_scale(), target);
  }

  // repeated float multihead_norm_bias = 2;
  if (this->_internal_multihead_norm_bias_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_multihead_norm_bias(), target);
  }

  // bytes multihead_project_kernel_qkv = 3;
  if (!this->_internal_multihead_project_kernel_qkv().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_multihead_project_kernel_qkv(), target);
  }

  // repeated float multihead_project_bias_qkv = 4;
  if (this->_internal_multihead_project_bias_qkv_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_multihead_project_bias_qkv(), target);
  }

  // bytes multihead_project_kernel_output = 5;
  if (!this->_internal_multihead_project_kernel_output().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_multihead_project_kernel_output(), target);
  }

  // repeated float multihead_project_bias_output = 6;
  if (this->_internal_multihead_project_bias_output_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_multihead_project_bias_output(), target);
  }

  // repeated float ffn_norm_scale = 7;
  if (this->_internal_ffn_norm_scale_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_ffn_norm_scale(), target);
  }

  // repeated float ffn_norm_bias = 8;
  if (this->_internal_ffn_norm_bias_size() > 0) {
    target = stream->WriteFixedPacked(8, _internal_ffn_norm_bias(), target);
  }

  // bytes ffn_first_kernel = 9;
  if (!this->_internal_ffn_first_kernel().empty()) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_ffn_first_kernel(), target);
  }

  // repeated float ffn_first_bias = 10;
  if (this->_internal_ffn_first_bias_size() > 0) {
    target = stream->WriteFixedPacked(10, _internal_ffn_first_bias(), target);
  }

  // bytes ffn_second_kernel = 11;
  if (!this->_internal_ffn_second_kernel().empty()) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_ffn_second_kernel(), target);
  }

  // repeated float ffn_second_bias = 12;
  if (this->_internal_ffn_second_bias_size() > 0) {
    target = stream->WriteFixedPacked(12, _internal_ffn_second_bias(), target);
  }

  // float multihead_project_kernel_qkv_clip_max = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_kernel_qkv_clip_max = this->_internal_multihead_project_kernel_qkv_clip_max();
  uint32_t raw_multihead_project_kernel_qkv_clip_max;
  memcpy(&raw_multihead_project_kernel_qkv_clip_max, &tmp_multihead_project_kernel_qkv_clip_max, sizeof(tmp_multihead_project_kernel_qkv_clip_max));
  if (raw_multihead_project_kernel_qkv_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_multihead_project_kernel_qkv_clip_max(), target);
  }

  // float multihead_project_kernel_output_clip_max = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_kernel_output_clip_max = this->_internal_multihead_project_kernel_output_clip_max();
  uint32_t raw_multihead_project_kernel_output_clip_max;
  memcpy(&raw_multihead_project_kernel_output_clip_max, &tmp_multihead_project_kernel_output_clip_max, sizeof(tmp_multihead_project_kernel_output_clip_max));
  if (raw_multihead_project_kernel_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_multihead_project_kernel_output_clip_max(), target);
  }

  // float ffn_first_kernel_clip_max = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_kernel_clip_max = this->_internal_ffn_first_kernel_clip_max();
  uint32_t raw_ffn_first_kernel_clip_max;
  memcpy(&raw_ffn_first_kernel_clip_max, &tmp_ffn_first_kernel_clip_max, sizeof(tmp_ffn_first_kernel_clip_max));
  if (raw_ffn_first_kernel_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_ffn_first_kernel_clip_max(), target);
  }

  // float ffn_second_kernel_clip_max = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_kernel_clip_max = this->_internal_ffn_second_kernel_clip_max();
  uint32_t raw_ffn_second_kernel_clip_max;
  memcpy(&raw_ffn_second_kernel_clip_max, &tmp_ffn_second_kernel_clip_max, sizeof(tmp_ffn_second_kernel_clip_max));
  if (raw_ffn_second_kernel_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_ffn_second_kernel_clip_max(), target);
  }

  // float multihead_ln_clip_max = 17;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_ln_clip_max = this->_internal_multihead_ln_clip_max();
  uint32_t raw_multihead_ln_clip_max;
  memcpy(&raw_multihead_ln_clip_max, &tmp_multihead_ln_clip_max, sizeof(tmp_multihead_ln_clip_max));
  if (raw_multihead_ln_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_multihead_ln_clip_max(), target);
  }

  // float multihead_project_output_clip_max = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_output_clip_max = this->_internal_multihead_project_output_clip_max();
  uint32_t raw_multihead_project_output_clip_max;
  memcpy(&raw_multihead_project_output_clip_max, &tmp_multihead_project_output_clip_max, sizeof(tmp_multihead_project_output_clip_max));
  if (raw_multihead_project_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_multihead_project_output_clip_max(), target);
  }

  // float ffn_ln_clip_max = 19;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_ln_clip_max = this->_internal_ffn_ln_clip_max();
  uint32_t raw_ffn_ln_clip_max;
  memcpy(&raw_ffn_ln_clip_max, &tmp_ffn_ln_clip_max, sizeof(tmp_ffn_ln_clip_max));
  if (raw_ffn_ln_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_ffn_ln_clip_max(), target);
  }

  // float ffn_first_act_clip_max = 20;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_act_clip_max = this->_internal_ffn_first_act_clip_max();
  uint32_t raw_ffn_first_act_clip_max;
  memcpy(&raw_ffn_first_act_clip_max, &tmp_ffn_first_act_clip_max, sizeof(tmp_ffn_first_act_clip_max));
  if (raw_ffn_first_act_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_ffn_first_act_clip_max(), target);
  }

  // float multihead_qkv_dense_clip_max = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_qkv_dense_clip_max = this->_internal_multihead_qkv_dense_clip_max();
  uint32_t raw_multihead_qkv_dense_clip_max;
  memcpy(&raw_multihead_qkv_dense_clip_max, &tmp_multihead_qkv_dense_clip_max, sizeof(tmp_multihead_qkv_dense_clip_max));
  if (raw_multihead_qkv_dense_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_multihead_qkv_dense_clip_max(), target);
  }

  // float multihead_output_dense_clip_max = 22;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_output_dense_clip_max = this->_internal_multihead_output_dense_clip_max();
  uint32_t raw_multihead_output_dense_clip_max;
  memcpy(&raw_multihead_output_dense_clip_max, &tmp_multihead_output_dense_clip_max, sizeof(tmp_multihead_output_dense_clip_max));
  if (raw_multihead_output_dense_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_multihead_output_dense_clip_max(), target);
  }

  // float ffn_first_output_clip_max = 23;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_output_clip_max = this->_internal_ffn_first_output_clip_max();
  uint32_t raw_ffn_first_output_clip_max;
  memcpy(&raw_ffn_first_output_clip_max, &tmp_ffn_first_output_clip_max, sizeof(tmp_ffn_first_output_clip_max));
  if (raw_ffn_first_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(23, this->_internal_ffn_first_output_clip_max(), target);
  }

  // float ffn_second_output_clip_max = 24;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_output_clip_max = this->_internal_ffn_second_output_clip_max();
  uint32_t raw_ffn_second_output_clip_max;
  memcpy(&raw_ffn_second_output_clip_max, &tmp_ffn_second_output_clip_max, sizeof(tmp_ffn_second_output_clip_max));
  if (raw_ffn_second_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_ffn_second_output_clip_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:QuantEncoderLayer)
  return target;
}

size_t QuantEncoderLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:QuantEncoderLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float multihead_norm_scale = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_multihead_norm_scale_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float multihead_norm_bias = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_multihead_norm_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float multihead_project_bias_qkv = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_multihead_project_bias_qkv_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float multihead_project_bias_output = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_multihead_project_bias_output_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_norm_scale = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_norm_scale_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_norm_bias = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_norm_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_first_bias = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_first_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_second_bias = 12;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_second_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // bytes multihead_project_kernel_qkv = 3;
  if (!this->_internal_multihead_project_kernel_qkv().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_multihead_project_kernel_qkv());
  }

  // bytes multihead_project_kernel_output = 5;
  if (!this->_internal_multihead_project_kernel_output().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_multihead_project_kernel_output());
  }

  // bytes ffn_first_kernel = 9;
  if (!this->_internal_ffn_first_kernel().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ffn_first_kernel());
  }

  // bytes ffn_second_kernel = 11;
  if (!this->_internal_ffn_second_kernel().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ffn_second_kernel());
  }

  // float multihead_project_kernel_qkv_clip_max = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_kernel_qkv_clip_max = this->_internal_multihead_project_kernel_qkv_clip_max();
  uint32_t raw_multihead_project_kernel_qkv_clip_max;
  memcpy(&raw_multihead_project_kernel_qkv_clip_max, &tmp_multihead_project_kernel_qkv_clip_max, sizeof(tmp_multihead_project_kernel_qkv_clip_max));
  if (raw_multihead_project_kernel_qkv_clip_max != 0) {
    total_size += 1 + 4;
  }

  // float multihead_project_kernel_output_clip_max = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_kernel_output_clip_max = this->_internal_multihead_project_kernel_output_clip_max();
  uint32_t raw_multihead_project_kernel_output_clip_max;
  memcpy(&raw_multihead_project_kernel_output_clip_max, &tmp_multihead_project_kernel_output_clip_max, sizeof(tmp_multihead_project_kernel_output_clip_max));
  if (raw_multihead_project_kernel_output_clip_max != 0) {
    total_size += 1 + 4;
  }

  // float ffn_first_kernel_clip_max = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_kernel_clip_max = this->_internal_ffn_first_kernel_clip_max();
  uint32_t raw_ffn_first_kernel_clip_max;
  memcpy(&raw_ffn_first_kernel_clip_max, &tmp_ffn_first_kernel_clip_max, sizeof(tmp_ffn_first_kernel_clip_max));
  if (raw_ffn_first_kernel_clip_max != 0) {
    total_size += 1 + 4;
  }

  // float ffn_second_kernel_clip_max = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_kernel_clip_max = this->_internal_ffn_second_kernel_clip_max();
  uint32_t raw_ffn_second_kernel_clip_max;
  memcpy(&raw_ffn_second_kernel_clip_max, &tmp_ffn_second_kernel_clip_max, sizeof(tmp_ffn_second_kernel_clip_max));
  if (raw_ffn_second_kernel_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float multihead_ln_clip_max = 17;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_ln_clip_max = this->_internal_multihead_ln_clip_max();
  uint32_t raw_multihead_ln_clip_max;
  memcpy(&raw_multihead_ln_clip_max, &tmp_multihead_ln_clip_max, sizeof(tmp_multihead_ln_clip_max));
  if (raw_multihead_ln_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float multihead_project_output_clip_max = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_output_clip_max = this->_internal_multihead_project_output_clip_max();
  uint32_t raw_multihead_project_output_clip_max;
  memcpy(&raw_multihead_project_output_clip_max, &tmp_multihead_project_output_clip_max, sizeof(tmp_multihead_project_output_clip_max));
  if (raw_multihead_project_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_ln_clip_max = 19;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_ln_clip_max = this->_internal_ffn_ln_clip_max();
  uint32_t raw_ffn_ln_clip_max;
  memcpy(&raw_ffn_ln_clip_max, &tmp_ffn_ln_clip_max, sizeof(tmp_ffn_ln_clip_max));
  if (raw_ffn_ln_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_first_act_clip_max = 20;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_act_clip_max = this->_internal_ffn_first_act_clip_max();
  uint32_t raw_ffn_first_act_clip_max;
  memcpy(&raw_ffn_first_act_clip_max, &tmp_ffn_first_act_clip_max, sizeof(tmp_ffn_first_act_clip_max));
  if (raw_ffn_first_act_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float multihead_qkv_dense_clip_max = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_qkv_dense_clip_max = this->_internal_multihead_qkv_dense_clip_max();
  uint32_t raw_multihead_qkv_dense_clip_max;
  memcpy(&raw_multihead_qkv_dense_clip_max, &tmp_multihead_qkv_dense_clip_max, sizeof(tmp_multihead_qkv_dense_clip_max));
  if (raw_multihead_qkv_dense_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float multihead_output_dense_clip_max = 22;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_output_dense_clip_max = this->_internal_multihead_output_dense_clip_max();
  uint32_t raw_multihead_output_dense_clip_max;
  memcpy(&raw_multihead_output_dense_clip_max, &tmp_multihead_output_dense_clip_max, sizeof(tmp_multihead_output_dense_clip_max));
  if (raw_multihead_output_dense_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_first_output_clip_max = 23;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_output_clip_max = this->_internal_ffn_first_output_clip_max();
  uint32_t raw_ffn_first_output_clip_max;
  memcpy(&raw_ffn_first_output_clip_max, &tmp_ffn_first_output_clip_max, sizeof(tmp_ffn_first_output_clip_max));
  if (raw_ffn_first_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_second_output_clip_max = 24;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_output_clip_max = this->_internal_ffn_second_output_clip_max();
  uint32_t raw_ffn_second_output_clip_max;
  memcpy(&raw_ffn_second_output_clip_max, &tmp_ffn_second_output_clip_max, sizeof(tmp_ffn_second_output_clip_max));
  if (raw_ffn_second_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QuantEncoderLayer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const QuantEncoderLayer*>(
      &from));
}

void QuantEncoderLayer::MergeFrom(const QuantEncoderLayer& from) {
  QuantEncoderLayer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:QuantEncoderLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.multihead_norm_scale_.MergeFrom(from._impl_.multihead_norm_scale_);
  _this->_impl_.multihead_norm_bias_.MergeFrom(from._impl_.multihead_norm_bias_);
  _this->_impl_.multihead_project_bias_qkv_.MergeFrom(from._impl_.multihead_project_bias_qkv_);
  _this->_impl_.multihead_project_bias_output_.MergeFrom(from._impl_.multihead_project_bias_output_);
  _this->_impl_.ffn_norm_scale_.MergeFrom(from._impl_.ffn_norm_scale_);
  _this->_impl_.ffn_norm_bias_.MergeFrom(from._impl_.ffn_norm_bias_);
  _this->_impl_.ffn_first_bias_.MergeFrom(from._impl_.ffn_first_bias_);
  _this->_impl_.ffn_second_bias_.MergeFrom(from._impl_.ffn_second_bias_);
  if (!from._internal_multihead_project_kernel_qkv().empty()) {
    _this->_internal_set_multihead_project_kernel_qkv(from._internal_multihead_project_kernel_qkv());
  }
  if (!from._internal_multihead_project_kernel_output().empty()) {
    _this->_internal_set_multihead_project_kernel_output(from._internal_multihead_project_kernel_output());
  }
  if (!from._internal_ffn_first_kernel().empty()) {
    _this->_internal_set_ffn_first_kernel(from._internal_ffn_first_kernel());
  }
  if (!from._internal_ffn_second_kernel().empty()) {
    _this->_internal_set_ffn_second_kernel(from._internal_ffn_second_kernel());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_kernel_qkv_clip_max = from._internal_multihead_project_kernel_qkv_clip_max();
  uint32_t raw_multihead_project_kernel_qkv_clip_max;
  memcpy(&raw_multihead_project_kernel_qkv_clip_max, &tmp_multihead_project_kernel_qkv_clip_max, sizeof(tmp_multihead_project_kernel_qkv_clip_max));
  if (raw_multihead_project_kernel_qkv_clip_max != 0) {
    _this->_internal_set_multihead_project_kernel_qkv_clip_max(from._internal_multihead_project_kernel_qkv_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_kernel_output_clip_max = from._internal_multihead_project_kernel_output_clip_max();
  uint32_t raw_multihead_project_kernel_output_clip_max;
  memcpy(&raw_multihead_project_kernel_output_clip_max, &tmp_multihead_project_kernel_output_clip_max, sizeof(tmp_multihead_project_kernel_output_clip_max));
  if (raw_multihead_project_kernel_output_clip_max != 0) {
    _this->_internal_set_multihead_project_kernel_output_clip_max(from._internal_multihead_project_kernel_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_kernel_clip_max = from._internal_ffn_first_kernel_clip_max();
  uint32_t raw_ffn_first_kernel_clip_max;
  memcpy(&raw_ffn_first_kernel_clip_max, &tmp_ffn_first_kernel_clip_max, sizeof(tmp_ffn_first_kernel_clip_max));
  if (raw_ffn_first_kernel_clip_max != 0) {
    _this->_internal_set_ffn_first_kernel_clip_max(from._internal_ffn_first_kernel_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_kernel_clip_max = from._internal_ffn_second_kernel_clip_max();
  uint32_t raw_ffn_second_kernel_clip_max;
  memcpy(&raw_ffn_second_kernel_clip_max, &tmp_ffn_second_kernel_clip_max, sizeof(tmp_ffn_second_kernel_clip_max));
  if (raw_ffn_second_kernel_clip_max != 0) {
    _this->_internal_set_ffn_second_kernel_clip_max(from._internal_ffn_second_kernel_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_ln_clip_max = from._internal_multihead_ln_clip_max();
  uint32_t raw_multihead_ln_clip_max;
  memcpy(&raw_multihead_ln_clip_max, &tmp_multihead_ln_clip_max, sizeof(tmp_multihead_ln_clip_max));
  if (raw_multihead_ln_clip_max != 0) {
    _this->_internal_set_multihead_ln_clip_max(from._internal_multihead_ln_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_project_output_clip_max = from._internal_multihead_project_output_clip_max();
  uint32_t raw_multihead_project_output_clip_max;
  memcpy(&raw_multihead_project_output_clip_max, &tmp_multihead_project_output_clip_max, sizeof(tmp_multihead_project_output_clip_max));
  if (raw_multihead_project_output_clip_max != 0) {
    _this->_internal_set_multihead_project_output_clip_max(from._internal_multihead_project_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_ln_clip_max = from._internal_ffn_ln_clip_max();
  uint32_t raw_ffn_ln_clip_max;
  memcpy(&raw_ffn_ln_clip_max, &tmp_ffn_ln_clip_max, sizeof(tmp_ffn_ln_clip_max));
  if (raw_ffn_ln_clip_max != 0) {
    _this->_internal_set_ffn_ln_clip_max(from._internal_ffn_ln_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_act_clip_max = from._internal_ffn_first_act_clip_max();
  uint32_t raw_ffn_first_act_clip_max;
  memcpy(&raw_ffn_first_act_clip_max, &tmp_ffn_first_act_clip_max, sizeof(tmp_ffn_first_act_clip_max));
  if (raw_ffn_first_act_clip_max != 0) {
    _this->_internal_set_ffn_first_act_clip_max(from._internal_ffn_first_act_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_qkv_dense_clip_max = from._internal_multihead_qkv_dense_clip_max();
  uint32_t raw_multihead_qkv_dense_clip_max;
  memcpy(&raw_multihead_qkv_dense_clip_max, &tmp_multihead_qkv_dense_clip_max, sizeof(tmp_multihead_qkv_dense_clip_max));
  if (raw_multihead_qkv_dense_clip_max != 0) {
    _this->_internal_set_multihead_qkv_dense_clip_max(from._internal_multihead_qkv_dense_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_multihead_output_dense_clip_max = from._internal_multihead_output_dense_clip_max();
  uint32_t raw_multihead_output_dense_clip_max;
  memcpy(&raw_multihead_output_dense_clip_max, &tmp_multihead_output_dense_clip_max, sizeof(tmp_multihead_output_dense_clip_max));
  if (raw_multihead_output_dense_clip_max != 0) {
    _this->_internal_set_multihead_output_dense_clip_max(from._internal_multihead_output_dense_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_output_clip_max = from._internal_ffn_first_output_clip_max();
  uint32_t raw_ffn_first_output_clip_max;
  memcpy(&raw_ffn_first_output_clip_max, &tmp_ffn_first_output_clip_max, sizeof(tmp_ffn_first_output_clip_max));
  if (raw_ffn_first_output_clip_max != 0) {
    _this->_internal_set_ffn_first_output_clip_max(from._internal_ffn_first_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_output_clip_max = from._internal_ffn_second_output_clip_max();
  uint32_t raw_ffn_second_output_clip_max;
  memcpy(&raw_ffn_second_output_clip_max, &tmp_ffn_second_output_clip_max, sizeof(tmp_ffn_second_output_clip_max));
  if (raw_ffn_second_output_clip_max != 0) {
    _this->_internal_set_ffn_second_output_clip_max(from._internal_ffn_second_output_clip_max());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void QuantEncoderLayer::CopyFrom(const QuantEncoderLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:QuantEncoderLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuantEncoderLayer::IsInitialized() const {
  return true;
}

void QuantEncoderLayer::InternalSwap(QuantEncoderLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.multihead_norm_scale_.InternalSwap(&other->_impl_.multihead_norm_scale_);
  _impl_.multihead_norm_bias_.InternalSwap(&other->_impl_.multihead_norm_bias_);
  _impl_.multihead_project_bias_qkv_.InternalSwap(&other->_impl_.multihead_project_bias_qkv_);
  _impl_.multihead_project_bias_output_.InternalSwap(&other->_impl_.multihead_project_bias_output_);
  _impl_.ffn_norm_scale_.InternalSwap(&other->_impl_.ffn_norm_scale_);
  _impl_.ffn_norm_bias_.InternalSwap(&other->_impl_.ffn_norm_bias_);
  _impl_.ffn_first_bias_.InternalSwap(&other->_impl_.ffn_first_bias_);
  _impl_.ffn_second_bias_.InternalSwap(&other->_impl_.ffn_second_bias_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.multihead_project_kernel_qkv_, lhs_arena,
      &other->_impl_.multihead_project_kernel_qkv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.multihead_project_kernel_output_, lhs_arena,
      &other->_impl_.multihead_project_kernel_output_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ffn_first_kernel_, lhs_arena,
      &other->_impl_.ffn_first_kernel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ffn_second_kernel_, lhs_arena,
      &other->_impl_.ffn_second_kernel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuantEncoderLayer, _impl_.ffn_second_output_clip_max_)
      + sizeof(QuantEncoderLayer::_impl_.ffn_second_output_clip_max_)
      - PROTOBUF_FIELD_OFFSET(QuantEncoderLayer, _impl_.multihead_project_kernel_qkv_clip_max_)>(
          reinterpret_cast<char*>(&_impl_.multihead_project_kernel_qkv_clip_max_),
          reinterpret_cast<char*>(&other->_impl_.multihead_project_kernel_qkv_clip_max_));
}

std::string QuantEncoderLayer::GetTypeName() const {
  return "QuantEncoderLayer";
}


// ===================================================================

class QuantDecoderLayer::_Internal {
 public:
};

QuantDecoderLayer::QuantDecoderLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:QuantDecoderLayer)
}
QuantDecoderLayer::QuantDecoderLayer(const QuantDecoderLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  QuantDecoderLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.self_norm_scale_){from._impl_.self_norm_scale_}
    , decltype(_impl_.self_norm_bias_){from._impl_.self_norm_bias_}
    , decltype(_impl_.self_project_bias_qkv_){from._impl_.self_project_bias_qkv_}
    , decltype(_impl_.self_project_bias_output_){from._impl_.self_project_bias_output_}
    , decltype(_impl_.encdec_norm_scale_){from._impl_.encdec_norm_scale_}
    , decltype(_impl_.encdec_norm_bias_){from._impl_.encdec_norm_bias_}
    , decltype(_impl_.encdec_project_bias_q_){from._impl_.encdec_project_bias_q_}
    , decltype(_impl_.encdec_project_bias_output_){from._impl_.encdec_project_bias_output_}
    , decltype(_impl_.ffn_norm_scale_){from._impl_.ffn_norm_scale_}
    , decltype(_impl_.ffn_norm_bias_){from._impl_.ffn_norm_bias_}
    , decltype(_impl_.ffn_first_bias_){from._impl_.ffn_first_bias_}
    , decltype(_impl_.ffn_second_bias_){from._impl_.ffn_second_bias_}
    , decltype(_impl_.self_project_kernel_qkv_){}
    , decltype(_impl_.self_project_kernel_output_){}
    , decltype(_impl_.encdec_project_kernel_q_){}
    , decltype(_impl_.encdec_project_kernel_output_){}
    , decltype(_impl_.ffn_first_kernel_){}
    , decltype(_impl_.ffn_second_kernel_){}
    , decltype(_impl_.self_project_kernel_qkv_clip_max_){}
    , decltype(_impl_.self_project_kernel_output_clip_max_){}
    , decltype(_impl_.encdec_project_kernel_q_clip_max_){}
    , decltype(_impl_.encdec_project_kernel_output_clip_max_){}
    , decltype(_impl_.ffn_first_kernel_clip_max_){}
    , decltype(_impl_.ffn_second_kernel_clip_max_){}
    , decltype(_impl_.self_ln_clip_max_){}
    , decltype(_impl_.self_project_output_clip_max_){}
    , decltype(_impl_.encdec_ln_clip_max_){}
    , decltype(_impl_.encdec_project_output_clip_max_){}
    , decltype(_impl_.ffn_ln_clip_max_){}
    , decltype(_impl_.ffn_first_act_clip_max_){}
    , decltype(_impl_.self_qkv_dense_clip_max_){}
    , decltype(_impl_.self_output_dense_clip_max_){}
    , decltype(_impl_.encdec_q_dense_clip_max_){}
    , decltype(_impl_.encdec_output_dense_clip_max_){}
    , decltype(_impl_.ffn_first_output_clip_max_){}
    , decltype(_impl_.ffn_second_output_clip_max_){}
    , decltype(_impl_.self_qkv_bias_out_clip_max_){}
    , decltype(_impl_.encdec_q_bias_out_clip_max_){}
    , decltype(_impl_.encdec_kv_bias_out_clip_max_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.self_project_kernel_qkv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.self_project_kernel_qkv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_self_project_kernel_qkv().empty()) {
    _this->_impl_.self_project_kernel_qkv_.Set(from._internal_self_project_kernel_qkv(), 
      _this->GetArenaForAllocation());
  }
  _impl_.self_project_kernel_output_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.self_project_kernel_output_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_self_project_kernel_output().empty()) {
    _this->_impl_.self_project_kernel_output_.Set(from._internal_self_project_kernel_output(), 
      _this->GetArenaForAllocation());
  }
  _impl_.encdec_project_kernel_q_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encdec_project_kernel_q_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encdec_project_kernel_q().empty()) {
    _this->_impl_.encdec_project_kernel_q_.Set(from._internal_encdec_project_kernel_q(), 
      _this->GetArenaForAllocation());
  }
  _impl_.encdec_project_kernel_output_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encdec_project_kernel_output_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encdec_project_kernel_output().empty()) {
    _this->_impl_.encdec_project_kernel_output_.Set(from._internal_encdec_project_kernel_output(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ffn_first_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_first_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ffn_first_kernel().empty()) {
    _this->_impl_.ffn_first_kernel_.Set(from._internal_ffn_first_kernel(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ffn_second_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_second_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ffn_second_kernel().empty()) {
    _this->_impl_.ffn_second_kernel_.Set(from._internal_ffn_second_kernel(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.self_project_kernel_qkv_clip_max_, &from._impl_.self_project_kernel_qkv_clip_max_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.encdec_kv_bias_out_clip_max_) -
    reinterpret_cast<char*>(&_impl_.self_project_kernel_qkv_clip_max_)) + sizeof(_impl_.encdec_kv_bias_out_clip_max_));
  // @@protoc_insertion_point(copy_constructor:QuantDecoderLayer)
}

inline void QuantDecoderLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.self_norm_scale_){arena}
    , decltype(_impl_.self_norm_bias_){arena}
    , decltype(_impl_.self_project_bias_qkv_){arena}
    , decltype(_impl_.self_project_bias_output_){arena}
    , decltype(_impl_.encdec_norm_scale_){arena}
    , decltype(_impl_.encdec_norm_bias_){arena}
    , decltype(_impl_.encdec_project_bias_q_){arena}
    , decltype(_impl_.encdec_project_bias_output_){arena}
    , decltype(_impl_.ffn_norm_scale_){arena}
    , decltype(_impl_.ffn_norm_bias_){arena}
    , decltype(_impl_.ffn_first_bias_){arena}
    , decltype(_impl_.ffn_second_bias_){arena}
    , decltype(_impl_.self_project_kernel_qkv_){}
    , decltype(_impl_.self_project_kernel_output_){}
    , decltype(_impl_.encdec_project_kernel_q_){}
    , decltype(_impl_.encdec_project_kernel_output_){}
    , decltype(_impl_.ffn_first_kernel_){}
    , decltype(_impl_.ffn_second_kernel_){}
    , decltype(_impl_.self_project_kernel_qkv_clip_max_){0}
    , decltype(_impl_.self_project_kernel_output_clip_max_){0}
    , decltype(_impl_.encdec_project_kernel_q_clip_max_){0}
    , decltype(_impl_.encdec_project_kernel_output_clip_max_){0}
    , decltype(_impl_.ffn_first_kernel_clip_max_){0}
    , decltype(_impl_.ffn_second_kernel_clip_max_){0}
    , decltype(_impl_.self_ln_clip_max_){0}
    , decltype(_impl_.self_project_output_clip_max_){0}
    , decltype(_impl_.encdec_ln_clip_max_){0}
    , decltype(_impl_.encdec_project_output_clip_max_){0}
    , decltype(_impl_.ffn_ln_clip_max_){0}
    , decltype(_impl_.ffn_first_act_clip_max_){0}
    , decltype(_impl_.self_qkv_dense_clip_max_){0}
    , decltype(_impl_.self_output_dense_clip_max_){0}
    , decltype(_impl_.encdec_q_dense_clip_max_){0}
    , decltype(_impl_.encdec_output_dense_clip_max_){0}
    , decltype(_impl_.ffn_first_output_clip_max_){0}
    , decltype(_impl_.ffn_second_output_clip_max_){0}
    , decltype(_impl_.self_qkv_bias_out_clip_max_){0}
    , decltype(_impl_.encdec_q_bias_out_clip_max_){0}
    , decltype(_impl_.encdec_kv_bias_out_clip_max_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.self_project_kernel_qkv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.self_project_kernel_qkv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.self_project_kernel_output_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.self_project_kernel_output_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encdec_project_kernel_q_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encdec_project_kernel_q_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encdec_project_kernel_output_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encdec_project_kernel_output_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ffn_first_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_first_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ffn_second_kernel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ffn_second_kernel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuantDecoderLayer::~QuantDecoderLayer() {
  // @@protoc_insertion_point(destructor:QuantDecoderLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuantDecoderLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.self_norm_scale_.~RepeatedField();
  _impl_.self_norm_bias_.~RepeatedField();
  _impl_.self_project_bias_qkv_.~RepeatedField();
  _impl_.self_project_bias_output_.~RepeatedField();
  _impl_.encdec_norm_scale_.~RepeatedField();
  _impl_.encdec_norm_bias_.~RepeatedField();
  _impl_.encdec_project_bias_q_.~RepeatedField();
  _impl_.encdec_project_bias_output_.~RepeatedField();
  _impl_.ffn_norm_scale_.~RepeatedField();
  _impl_.ffn_norm_bias_.~RepeatedField();
  _impl_.ffn_first_bias_.~RepeatedField();
  _impl_.ffn_second_bias_.~RepeatedField();
  _impl_.self_project_kernel_qkv_.Destroy();
  _impl_.self_project_kernel_output_.Destroy();
  _impl_.encdec_project_kernel_q_.Destroy();
  _impl_.encdec_project_kernel_output_.Destroy();
  _impl_.ffn_first_kernel_.Destroy();
  _impl_.ffn_second_kernel_.Destroy();
}

void QuantDecoderLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuantDecoderLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:QuantDecoderLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.self_norm_scale_.Clear();
  _impl_.self_norm_bias_.Clear();
  _impl_.self_project_bias_qkv_.Clear();
  _impl_.self_project_bias_output_.Clear();
  _impl_.encdec_norm_scale_.Clear();
  _impl_.encdec_norm_bias_.Clear();
  _impl_.encdec_project_bias_q_.Clear();
  _impl_.encdec_project_bias_output_.Clear();
  _impl_.ffn_norm_scale_.Clear();
  _impl_.ffn_norm_bias_.Clear();
  _impl_.ffn_first_bias_.Clear();
  _impl_.ffn_second_bias_.Clear();
  _impl_.self_project_kernel_qkv_.ClearToEmpty();
  _impl_.self_project_kernel_output_.ClearToEmpty();
  _impl_.encdec_project_kernel_q_.ClearToEmpty();
  _impl_.encdec_project_kernel_output_.ClearToEmpty();
  _impl_.ffn_first_kernel_.ClearToEmpty();
  _impl_.ffn_second_kernel_.ClearToEmpty();
  ::memset(&_impl_.self_project_kernel_qkv_clip_max_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.encdec_kv_bias_out_clip_max_) -
      reinterpret_cast<char*>(&_impl_.self_project_kernel_qkv_clip_max_)) + sizeof(_impl_.encdec_kv_bias_out_clip_max_));
  _internal_metadata_.Clear<std::string>();
}

const char* QuantDecoderLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float self_norm_scale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_self_norm_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_self_norm_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float self_norm_bias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_self_norm_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_self_norm_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes self_project_kernel_qkv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_self_project_kernel_qkv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float self_project_bias_qkv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_self_project_bias_qkv(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 37) {
          _internal_add_self_project_bias_qkv(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes self_project_kernel_output = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_self_project_kernel_output();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float self_project_bias_output = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_self_project_bias_output(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 53) {
          _internal_add_self_project_bias_output(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float encdec_norm_scale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_encdec_norm_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 61) {
          _internal_add_encdec_norm_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float encdec_norm_bias = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_encdec_norm_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 69) {
          _internal_add_encdec_norm_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes encdec_project_kernel_q = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_encdec_project_kernel_q();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float encdec_project_bias_q = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_encdec_project_bias_q(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 85) {
          _internal_add_encdec_project_bias_q(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes encdec_project_kernel_output = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_encdec_project_kernel_output();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float encdec_project_bias_output = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_encdec_project_bias_output(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 101) {
          _internal_add_encdec_project_bias_output(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_norm_scale = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_norm_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 109) {
          _internal_add_ffn_norm_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_norm_bias = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_norm_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 117) {
          _internal_add_ffn_norm_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes ffn_first_kernel = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_ffn_first_kernel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_first_bias = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_first_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 133) {
          _internal_add_ffn_first_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes ffn_second_kernel = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_ffn_second_kernel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float ffn_second_bias = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_ffn_second_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 149) {
          _internal_add_ffn_second_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float self_project_kernel_qkv_clip_max = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _impl_.self_project_kernel_qkv_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float self_project_kernel_output_clip_max = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _impl_.self_project_kernel_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_project_kernel_q_clip_max = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _impl_.encdec_project_kernel_q_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_project_kernel_output_clip_max = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _impl_.encdec_project_kernel_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_first_kernel_clip_max = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          _impl_.ffn_first_kernel_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_second_kernel_clip_max = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _impl_.ffn_second_kernel_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float self_ln_clip_max = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _impl_.self_ln_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float self_project_output_clip_max = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 213)) {
          _impl_.self_project_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_ln_clip_max = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 221)) {
          _impl_.encdec_ln_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_project_output_clip_max = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 229)) {
          _impl_.encdec_project_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_ln_clip_max = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 237)) {
          _impl_.ffn_ln_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_first_act_clip_max = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 245)) {
          _impl_.ffn_first_act_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float self_qkv_dense_clip_max = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          _impl_.self_qkv_dense_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float self_output_dense_clip_max = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          _impl_.self_output_dense_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_q_dense_clip_max = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.encdec_q_dense_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_output_dense_clip_max = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.encdec_output_dense_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_first_output_clip_max = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.ffn_first_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ffn_second_output_clip_max = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.ffn_second_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float self_qkv_bias_out_clip_max = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.self_qkv_bias_out_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_q_bias_out_clip_max = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.encdec_q_bias_out_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encdec_kv_bias_out_clip_max = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.encdec_kv_bias_out_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuantDecoderLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:QuantDecoderLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float self_norm_scale = 1;
  if (this->_internal_self_norm_scale_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_self_norm_scale(), target);
  }

  // repeated float self_norm_bias = 2;
  if (this->_internal_self_norm_bias_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_self_norm_bias(), target);
  }

  // bytes self_project_kernel_qkv = 3;
  if (!this->_internal_self_project_kernel_qkv().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_self_project_kernel_qkv(), target);
  }

  // repeated float self_project_bias_qkv = 4;
  if (this->_internal_self_project_bias_qkv_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_self_project_bias_qkv(), target);
  }

  // bytes self_project_kernel_output = 5;
  if (!this->_internal_self_project_kernel_output().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_self_project_kernel_output(), target);
  }

  // repeated float self_project_bias_output = 6;
  if (this->_internal_self_project_bias_output_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_self_project_bias_output(), target);
  }

  // repeated float encdec_norm_scale = 7;
  if (this->_internal_encdec_norm_scale_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_encdec_norm_scale(), target);
  }

  // repeated float encdec_norm_bias = 8;
  if (this->_internal_encdec_norm_bias_size() > 0) {
    target = stream->WriteFixedPacked(8, _internal_encdec_norm_bias(), target);
  }

  // bytes encdec_project_kernel_q = 9;
  if (!this->_internal_encdec_project_kernel_q().empty()) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_encdec_project_kernel_q(), target);
  }

  // repeated float encdec_project_bias_q = 10;
  if (this->_internal_encdec_project_bias_q_size() > 0) {
    target = stream->WriteFixedPacked(10, _internal_encdec_project_bias_q(), target);
  }

  // bytes encdec_project_kernel_output = 11;
  if (!this->_internal_encdec_project_kernel_output().empty()) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_encdec_project_kernel_output(), target);
  }

  // repeated float encdec_project_bias_output = 12;
  if (this->_internal_encdec_project_bias_output_size() > 0) {
    target = stream->WriteFixedPacked(12, _internal_encdec_project_bias_output(), target);
  }

  // repeated float ffn_norm_scale = 13;
  if (this->_internal_ffn_norm_scale_size() > 0) {
    target = stream->WriteFixedPacked(13, _internal_ffn_norm_scale(), target);
  }

  // repeated float ffn_norm_bias = 14;
  if (this->_internal_ffn_norm_bias_size() > 0) {
    target = stream->WriteFixedPacked(14, _internal_ffn_norm_bias(), target);
  }

  // bytes ffn_first_kernel = 15;
  if (!this->_internal_ffn_first_kernel().empty()) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_ffn_first_kernel(), target);
  }

  // repeated float ffn_first_bias = 16;
  if (this->_internal_ffn_first_bias_size() > 0) {
    target = stream->WriteFixedPacked(16, _internal_ffn_first_bias(), target);
  }

  // bytes ffn_second_kernel = 17;
  if (!this->_internal_ffn_second_kernel().empty()) {
    target = stream->WriteBytesMaybeAliased(
        17, this->_internal_ffn_second_kernel(), target);
  }

  // repeated float ffn_second_bias = 18;
  if (this->_internal_ffn_second_bias_size() > 0) {
    target = stream->WriteFixedPacked(18, _internal_ffn_second_bias(), target);
  }

  // float self_project_kernel_qkv_clip_max = 19;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_kernel_qkv_clip_max = this->_internal_self_project_kernel_qkv_clip_max();
  uint32_t raw_self_project_kernel_qkv_clip_max;
  memcpy(&raw_self_project_kernel_qkv_clip_max, &tmp_self_project_kernel_qkv_clip_max, sizeof(tmp_self_project_kernel_qkv_clip_max));
  if (raw_self_project_kernel_qkv_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_self_project_kernel_qkv_clip_max(), target);
  }

  // float self_project_kernel_output_clip_max = 20;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_kernel_output_clip_max = this->_internal_self_project_kernel_output_clip_max();
  uint32_t raw_self_project_kernel_output_clip_max;
  memcpy(&raw_self_project_kernel_output_clip_max, &tmp_self_project_kernel_output_clip_max, sizeof(tmp_self_project_kernel_output_clip_max));
  if (raw_self_project_kernel_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_self_project_kernel_output_clip_max(), target);
  }

  // float encdec_project_kernel_q_clip_max = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_kernel_q_clip_max = this->_internal_encdec_project_kernel_q_clip_max();
  uint32_t raw_encdec_project_kernel_q_clip_max;
  memcpy(&raw_encdec_project_kernel_q_clip_max, &tmp_encdec_project_kernel_q_clip_max, sizeof(tmp_encdec_project_kernel_q_clip_max));
  if (raw_encdec_project_kernel_q_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_encdec_project_kernel_q_clip_max(), target);
  }

  // float encdec_project_kernel_output_clip_max = 22;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_kernel_output_clip_max = this->_internal_encdec_project_kernel_output_clip_max();
  uint32_t raw_encdec_project_kernel_output_clip_max;
  memcpy(&raw_encdec_project_kernel_output_clip_max, &tmp_encdec_project_kernel_output_clip_max, sizeof(tmp_encdec_project_kernel_output_clip_max));
  if (raw_encdec_project_kernel_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_encdec_project_kernel_output_clip_max(), target);
  }

  // float ffn_first_kernel_clip_max = 23;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_kernel_clip_max = this->_internal_ffn_first_kernel_clip_max();
  uint32_t raw_ffn_first_kernel_clip_max;
  memcpy(&raw_ffn_first_kernel_clip_max, &tmp_ffn_first_kernel_clip_max, sizeof(tmp_ffn_first_kernel_clip_max));
  if (raw_ffn_first_kernel_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(23, this->_internal_ffn_first_kernel_clip_max(), target);
  }

  // float ffn_second_kernel_clip_max = 24;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_kernel_clip_max = this->_internal_ffn_second_kernel_clip_max();
  uint32_t raw_ffn_second_kernel_clip_max;
  memcpy(&raw_ffn_second_kernel_clip_max, &tmp_ffn_second_kernel_clip_max, sizeof(tmp_ffn_second_kernel_clip_max));
  if (raw_ffn_second_kernel_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_ffn_second_kernel_clip_max(), target);
  }

  // float self_ln_clip_max = 25;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_ln_clip_max = this->_internal_self_ln_clip_max();
  uint32_t raw_self_ln_clip_max;
  memcpy(&raw_self_ln_clip_max, &tmp_self_ln_clip_max, sizeof(tmp_self_ln_clip_max));
  if (raw_self_ln_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_self_ln_clip_max(), target);
  }

  // float self_project_output_clip_max = 26;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_output_clip_max = this->_internal_self_project_output_clip_max();
  uint32_t raw_self_project_output_clip_max;
  memcpy(&raw_self_project_output_clip_max, &tmp_self_project_output_clip_max, sizeof(tmp_self_project_output_clip_max));
  if (raw_self_project_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(26, this->_internal_self_project_output_clip_max(), target);
  }

  // float encdec_ln_clip_max = 27;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_ln_clip_max = this->_internal_encdec_ln_clip_max();
  uint32_t raw_encdec_ln_clip_max;
  memcpy(&raw_encdec_ln_clip_max, &tmp_encdec_ln_clip_max, sizeof(tmp_encdec_ln_clip_max));
  if (raw_encdec_ln_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(27, this->_internal_encdec_ln_clip_max(), target);
  }

  // float encdec_project_output_clip_max = 28;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_output_clip_max = this->_internal_encdec_project_output_clip_max();
  uint32_t raw_encdec_project_output_clip_max;
  memcpy(&raw_encdec_project_output_clip_max, &tmp_encdec_project_output_clip_max, sizeof(tmp_encdec_project_output_clip_max));
  if (raw_encdec_project_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(28, this->_internal_encdec_project_output_clip_max(), target);
  }

  // float ffn_ln_clip_max = 29;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_ln_clip_max = this->_internal_ffn_ln_clip_max();
  uint32_t raw_ffn_ln_clip_max;
  memcpy(&raw_ffn_ln_clip_max, &tmp_ffn_ln_clip_max, sizeof(tmp_ffn_ln_clip_max));
  if (raw_ffn_ln_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(29, this->_internal_ffn_ln_clip_max(), target);
  }

  // float ffn_first_act_clip_max = 30;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_act_clip_max = this->_internal_ffn_first_act_clip_max();
  uint32_t raw_ffn_first_act_clip_max;
  memcpy(&raw_ffn_first_act_clip_max, &tmp_ffn_first_act_clip_max, sizeof(tmp_ffn_first_act_clip_max));
  if (raw_ffn_first_act_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(30, this->_internal_ffn_first_act_clip_max(), target);
  }

  // float self_qkv_dense_clip_max = 31;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_qkv_dense_clip_max = this->_internal_self_qkv_dense_clip_max();
  uint32_t raw_self_qkv_dense_clip_max;
  memcpy(&raw_self_qkv_dense_clip_max, &tmp_self_qkv_dense_clip_max, sizeof(tmp_self_qkv_dense_clip_max));
  if (raw_self_qkv_dense_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(31, this->_internal_self_qkv_dense_clip_max(), target);
  }

  // float self_output_dense_clip_max = 32;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_output_dense_clip_max = this->_internal_self_output_dense_clip_max();
  uint32_t raw_self_output_dense_clip_max;
  memcpy(&raw_self_output_dense_clip_max, &tmp_self_output_dense_clip_max, sizeof(tmp_self_output_dense_clip_max));
  if (raw_self_output_dense_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(32, this->_internal_self_output_dense_clip_max(), target);
  }

  // float encdec_q_dense_clip_max = 33;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_q_dense_clip_max = this->_internal_encdec_q_dense_clip_max();
  uint32_t raw_encdec_q_dense_clip_max;
  memcpy(&raw_encdec_q_dense_clip_max, &tmp_encdec_q_dense_clip_max, sizeof(tmp_encdec_q_dense_clip_max));
  if (raw_encdec_q_dense_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(33, this->_internal_encdec_q_dense_clip_max(), target);
  }

  // float encdec_output_dense_clip_max = 34;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_output_dense_clip_max = this->_internal_encdec_output_dense_clip_max();
  uint32_t raw_encdec_output_dense_clip_max;
  memcpy(&raw_encdec_output_dense_clip_max, &tmp_encdec_output_dense_clip_max, sizeof(tmp_encdec_output_dense_clip_max));
  if (raw_encdec_output_dense_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(34, this->_internal_encdec_output_dense_clip_max(), target);
  }

  // float ffn_first_output_clip_max = 35;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_output_clip_max = this->_internal_ffn_first_output_clip_max();
  uint32_t raw_ffn_first_output_clip_max;
  memcpy(&raw_ffn_first_output_clip_max, &tmp_ffn_first_output_clip_max, sizeof(tmp_ffn_first_output_clip_max));
  if (raw_ffn_first_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(35, this->_internal_ffn_first_output_clip_max(), target);
  }

  // float ffn_second_output_clip_max = 36;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_output_clip_max = this->_internal_ffn_second_output_clip_max();
  uint32_t raw_ffn_second_output_clip_max;
  memcpy(&raw_ffn_second_output_clip_max, &tmp_ffn_second_output_clip_max, sizeof(tmp_ffn_second_output_clip_max));
  if (raw_ffn_second_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(36, this->_internal_ffn_second_output_clip_max(), target);
  }

  // float self_qkv_bias_out_clip_max = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_qkv_bias_out_clip_max = this->_internal_self_qkv_bias_out_clip_max();
  uint32_t raw_self_qkv_bias_out_clip_max;
  memcpy(&raw_self_qkv_bias_out_clip_max, &tmp_self_qkv_bias_out_clip_max, sizeof(tmp_self_qkv_bias_out_clip_max));
  if (raw_self_qkv_bias_out_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(37, this->_internal_self_qkv_bias_out_clip_max(), target);
  }

  // float encdec_q_bias_out_clip_max = 38;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_q_bias_out_clip_max = this->_internal_encdec_q_bias_out_clip_max();
  uint32_t raw_encdec_q_bias_out_clip_max;
  memcpy(&raw_encdec_q_bias_out_clip_max, &tmp_encdec_q_bias_out_clip_max, sizeof(tmp_encdec_q_bias_out_clip_max));
  if (raw_encdec_q_bias_out_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(38, this->_internal_encdec_q_bias_out_clip_max(), target);
  }

  // float encdec_kv_bias_out_clip_max = 39;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_kv_bias_out_clip_max = this->_internal_encdec_kv_bias_out_clip_max();
  uint32_t raw_encdec_kv_bias_out_clip_max;
  memcpy(&raw_encdec_kv_bias_out_clip_max, &tmp_encdec_kv_bias_out_clip_max, sizeof(tmp_encdec_kv_bias_out_clip_max));
  if (raw_encdec_kv_bias_out_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(39, this->_internal_encdec_kv_bias_out_clip_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:QuantDecoderLayer)
  return target;
}

size_t QuantDecoderLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:QuantDecoderLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float self_norm_scale = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_self_norm_scale_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float self_norm_bias = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_self_norm_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float self_project_bias_qkv = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_self_project_bias_qkv_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float self_project_bias_output = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_self_project_bias_output_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float encdec_norm_scale = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_encdec_norm_scale_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float encdec_norm_bias = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_encdec_norm_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float encdec_project_bias_q = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_encdec_project_bias_q_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float encdec_project_bias_output = 12;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_encdec_project_bias_output_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_norm_scale = 13;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_norm_scale_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_norm_bias = 14;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_norm_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_first_bias = 16;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_first_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float ffn_second_bias = 18;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ffn_second_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // bytes self_project_kernel_qkv = 3;
  if (!this->_internal_self_project_kernel_qkv().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_self_project_kernel_qkv());
  }

  // bytes self_project_kernel_output = 5;
  if (!this->_internal_self_project_kernel_output().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_self_project_kernel_output());
  }

  // bytes encdec_project_kernel_q = 9;
  if (!this->_internal_encdec_project_kernel_q().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encdec_project_kernel_q());
  }

  // bytes encdec_project_kernel_output = 11;
  if (!this->_internal_encdec_project_kernel_output().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encdec_project_kernel_output());
  }

  // bytes ffn_first_kernel = 15;
  if (!this->_internal_ffn_first_kernel().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ffn_first_kernel());
  }

  // bytes ffn_second_kernel = 17;
  if (!this->_internal_ffn_second_kernel().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ffn_second_kernel());
  }

  // float self_project_kernel_qkv_clip_max = 19;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_kernel_qkv_clip_max = this->_internal_self_project_kernel_qkv_clip_max();
  uint32_t raw_self_project_kernel_qkv_clip_max;
  memcpy(&raw_self_project_kernel_qkv_clip_max, &tmp_self_project_kernel_qkv_clip_max, sizeof(tmp_self_project_kernel_qkv_clip_max));
  if (raw_self_project_kernel_qkv_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float self_project_kernel_output_clip_max = 20;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_kernel_output_clip_max = this->_internal_self_project_kernel_output_clip_max();
  uint32_t raw_self_project_kernel_output_clip_max;
  memcpy(&raw_self_project_kernel_output_clip_max, &tmp_self_project_kernel_output_clip_max, sizeof(tmp_self_project_kernel_output_clip_max));
  if (raw_self_project_kernel_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_project_kernel_q_clip_max = 21;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_kernel_q_clip_max = this->_internal_encdec_project_kernel_q_clip_max();
  uint32_t raw_encdec_project_kernel_q_clip_max;
  memcpy(&raw_encdec_project_kernel_q_clip_max, &tmp_encdec_project_kernel_q_clip_max, sizeof(tmp_encdec_project_kernel_q_clip_max));
  if (raw_encdec_project_kernel_q_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_project_kernel_output_clip_max = 22;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_kernel_output_clip_max = this->_internal_encdec_project_kernel_output_clip_max();
  uint32_t raw_encdec_project_kernel_output_clip_max;
  memcpy(&raw_encdec_project_kernel_output_clip_max, &tmp_encdec_project_kernel_output_clip_max, sizeof(tmp_encdec_project_kernel_output_clip_max));
  if (raw_encdec_project_kernel_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_first_kernel_clip_max = 23;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_kernel_clip_max = this->_internal_ffn_first_kernel_clip_max();
  uint32_t raw_ffn_first_kernel_clip_max;
  memcpy(&raw_ffn_first_kernel_clip_max, &tmp_ffn_first_kernel_clip_max, sizeof(tmp_ffn_first_kernel_clip_max));
  if (raw_ffn_first_kernel_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_second_kernel_clip_max = 24;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_kernel_clip_max = this->_internal_ffn_second_kernel_clip_max();
  uint32_t raw_ffn_second_kernel_clip_max;
  memcpy(&raw_ffn_second_kernel_clip_max, &tmp_ffn_second_kernel_clip_max, sizeof(tmp_ffn_second_kernel_clip_max));
  if (raw_ffn_second_kernel_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float self_ln_clip_max = 25;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_ln_clip_max = this->_internal_self_ln_clip_max();
  uint32_t raw_self_ln_clip_max;
  memcpy(&raw_self_ln_clip_max, &tmp_self_ln_clip_max, sizeof(tmp_self_ln_clip_max));
  if (raw_self_ln_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float self_project_output_clip_max = 26;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_output_clip_max = this->_internal_self_project_output_clip_max();
  uint32_t raw_self_project_output_clip_max;
  memcpy(&raw_self_project_output_clip_max, &tmp_self_project_output_clip_max, sizeof(tmp_self_project_output_clip_max));
  if (raw_self_project_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_ln_clip_max = 27;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_ln_clip_max = this->_internal_encdec_ln_clip_max();
  uint32_t raw_encdec_ln_clip_max;
  memcpy(&raw_encdec_ln_clip_max, &tmp_encdec_ln_clip_max, sizeof(tmp_encdec_ln_clip_max));
  if (raw_encdec_ln_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_project_output_clip_max = 28;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_output_clip_max = this->_internal_encdec_project_output_clip_max();
  uint32_t raw_encdec_project_output_clip_max;
  memcpy(&raw_encdec_project_output_clip_max, &tmp_encdec_project_output_clip_max, sizeof(tmp_encdec_project_output_clip_max));
  if (raw_encdec_project_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_ln_clip_max = 29;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_ln_clip_max = this->_internal_ffn_ln_clip_max();
  uint32_t raw_ffn_ln_clip_max;
  memcpy(&raw_ffn_ln_clip_max, &tmp_ffn_ln_clip_max, sizeof(tmp_ffn_ln_clip_max));
  if (raw_ffn_ln_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_first_act_clip_max = 30;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_act_clip_max = this->_internal_ffn_first_act_clip_max();
  uint32_t raw_ffn_first_act_clip_max;
  memcpy(&raw_ffn_first_act_clip_max, &tmp_ffn_first_act_clip_max, sizeof(tmp_ffn_first_act_clip_max));
  if (raw_ffn_first_act_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float self_qkv_dense_clip_max = 31;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_qkv_dense_clip_max = this->_internal_self_qkv_dense_clip_max();
  uint32_t raw_self_qkv_dense_clip_max;
  memcpy(&raw_self_qkv_dense_clip_max, &tmp_self_qkv_dense_clip_max, sizeof(tmp_self_qkv_dense_clip_max));
  if (raw_self_qkv_dense_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float self_output_dense_clip_max = 32;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_output_dense_clip_max = this->_internal_self_output_dense_clip_max();
  uint32_t raw_self_output_dense_clip_max;
  memcpy(&raw_self_output_dense_clip_max, &tmp_self_output_dense_clip_max, sizeof(tmp_self_output_dense_clip_max));
  if (raw_self_output_dense_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_q_dense_clip_max = 33;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_q_dense_clip_max = this->_internal_encdec_q_dense_clip_max();
  uint32_t raw_encdec_q_dense_clip_max;
  memcpy(&raw_encdec_q_dense_clip_max, &tmp_encdec_q_dense_clip_max, sizeof(tmp_encdec_q_dense_clip_max));
  if (raw_encdec_q_dense_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_output_dense_clip_max = 34;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_output_dense_clip_max = this->_internal_encdec_output_dense_clip_max();
  uint32_t raw_encdec_output_dense_clip_max;
  memcpy(&raw_encdec_output_dense_clip_max, &tmp_encdec_output_dense_clip_max, sizeof(tmp_encdec_output_dense_clip_max));
  if (raw_encdec_output_dense_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_first_output_clip_max = 35;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_output_clip_max = this->_internal_ffn_first_output_clip_max();
  uint32_t raw_ffn_first_output_clip_max;
  memcpy(&raw_ffn_first_output_clip_max, &tmp_ffn_first_output_clip_max, sizeof(tmp_ffn_first_output_clip_max));
  if (raw_ffn_first_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float ffn_second_output_clip_max = 36;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_output_clip_max = this->_internal_ffn_second_output_clip_max();
  uint32_t raw_ffn_second_output_clip_max;
  memcpy(&raw_ffn_second_output_clip_max, &tmp_ffn_second_output_clip_max, sizeof(tmp_ffn_second_output_clip_max));
  if (raw_ffn_second_output_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float self_qkv_bias_out_clip_max = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_qkv_bias_out_clip_max = this->_internal_self_qkv_bias_out_clip_max();
  uint32_t raw_self_qkv_bias_out_clip_max;
  memcpy(&raw_self_qkv_bias_out_clip_max, &tmp_self_qkv_bias_out_clip_max, sizeof(tmp_self_qkv_bias_out_clip_max));
  if (raw_self_qkv_bias_out_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_q_bias_out_clip_max = 38;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_q_bias_out_clip_max = this->_internal_encdec_q_bias_out_clip_max();
  uint32_t raw_encdec_q_bias_out_clip_max;
  memcpy(&raw_encdec_q_bias_out_clip_max, &tmp_encdec_q_bias_out_clip_max, sizeof(tmp_encdec_q_bias_out_clip_max));
  if (raw_encdec_q_bias_out_clip_max != 0) {
    total_size += 2 + 4;
  }

  // float encdec_kv_bias_out_clip_max = 39;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_kv_bias_out_clip_max = this->_internal_encdec_kv_bias_out_clip_max();
  uint32_t raw_encdec_kv_bias_out_clip_max;
  memcpy(&raw_encdec_kv_bias_out_clip_max, &tmp_encdec_kv_bias_out_clip_max, sizeof(tmp_encdec_kv_bias_out_clip_max));
  if (raw_encdec_kv_bias_out_clip_max != 0) {
    total_size += 2 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QuantDecoderLayer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const QuantDecoderLayer*>(
      &from));
}

void QuantDecoderLayer::MergeFrom(const QuantDecoderLayer& from) {
  QuantDecoderLayer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:QuantDecoderLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.self_norm_scale_.MergeFrom(from._impl_.self_norm_scale_);
  _this->_impl_.self_norm_bias_.MergeFrom(from._impl_.self_norm_bias_);
  _this->_impl_.self_project_bias_qkv_.MergeFrom(from._impl_.self_project_bias_qkv_);
  _this->_impl_.self_project_bias_output_.MergeFrom(from._impl_.self_project_bias_output_);
  _this->_impl_.encdec_norm_scale_.MergeFrom(from._impl_.encdec_norm_scale_);
  _this->_impl_.encdec_norm_bias_.MergeFrom(from._impl_.encdec_norm_bias_);
  _this->_impl_.encdec_project_bias_q_.MergeFrom(from._impl_.encdec_project_bias_q_);
  _this->_impl_.encdec_project_bias_output_.MergeFrom(from._impl_.encdec_project_bias_output_);
  _this->_impl_.ffn_norm_scale_.MergeFrom(from._impl_.ffn_norm_scale_);
  _this->_impl_.ffn_norm_bias_.MergeFrom(from._impl_.ffn_norm_bias_);
  _this->_impl_.ffn_first_bias_.MergeFrom(from._impl_.ffn_first_bias_);
  _this->_impl_.ffn_second_bias_.MergeFrom(from._impl_.ffn_second_bias_);
  if (!from._internal_self_project_kernel_qkv().empty()) {
    _this->_internal_set_self_project_kernel_qkv(from._internal_self_project_kernel_qkv());
  }
  if (!from._internal_self_project_kernel_output().empty()) {
    _this->_internal_set_self_project_kernel_output(from._internal_self_project_kernel_output());
  }
  if (!from._internal_encdec_project_kernel_q().empty()) {
    _this->_internal_set_encdec_project_kernel_q(from._internal_encdec_project_kernel_q());
  }
  if (!from._internal_encdec_project_kernel_output().empty()) {
    _this->_internal_set_encdec_project_kernel_output(from._internal_encdec_project_kernel_output());
  }
  if (!from._internal_ffn_first_kernel().empty()) {
    _this->_internal_set_ffn_first_kernel(from._internal_ffn_first_kernel());
  }
  if (!from._internal_ffn_second_kernel().empty()) {
    _this->_internal_set_ffn_second_kernel(from._internal_ffn_second_kernel());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_kernel_qkv_clip_max = from._internal_self_project_kernel_qkv_clip_max();
  uint32_t raw_self_project_kernel_qkv_clip_max;
  memcpy(&raw_self_project_kernel_qkv_clip_max, &tmp_self_project_kernel_qkv_clip_max, sizeof(tmp_self_project_kernel_qkv_clip_max));
  if (raw_self_project_kernel_qkv_clip_max != 0) {
    _this->_internal_set_self_project_kernel_qkv_clip_max(from._internal_self_project_kernel_qkv_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_kernel_output_clip_max = from._internal_self_project_kernel_output_clip_max();
  uint32_t raw_self_project_kernel_output_clip_max;
  memcpy(&raw_self_project_kernel_output_clip_max, &tmp_self_project_kernel_output_clip_max, sizeof(tmp_self_project_kernel_output_clip_max));
  if (raw_self_project_kernel_output_clip_max != 0) {
    _this->_internal_set_self_project_kernel_output_clip_max(from._internal_self_project_kernel_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_kernel_q_clip_max = from._internal_encdec_project_kernel_q_clip_max();
  uint32_t raw_encdec_project_kernel_q_clip_max;
  memcpy(&raw_encdec_project_kernel_q_clip_max, &tmp_encdec_project_kernel_q_clip_max, sizeof(tmp_encdec_project_kernel_q_clip_max));
  if (raw_encdec_project_kernel_q_clip_max != 0) {
    _this->_internal_set_encdec_project_kernel_q_clip_max(from._internal_encdec_project_kernel_q_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_kernel_output_clip_max = from._internal_encdec_project_kernel_output_clip_max();
  uint32_t raw_encdec_project_kernel_output_clip_max;
  memcpy(&raw_encdec_project_kernel_output_clip_max, &tmp_encdec_project_kernel_output_clip_max, sizeof(tmp_encdec_project_kernel_output_clip_max));
  if (raw_encdec_project_kernel_output_clip_max != 0) {
    _this->_internal_set_encdec_project_kernel_output_clip_max(from._internal_encdec_project_kernel_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_kernel_clip_max = from._internal_ffn_first_kernel_clip_max();
  uint32_t raw_ffn_first_kernel_clip_max;
  memcpy(&raw_ffn_first_kernel_clip_max, &tmp_ffn_first_kernel_clip_max, sizeof(tmp_ffn_first_kernel_clip_max));
  if (raw_ffn_first_kernel_clip_max != 0) {
    _this->_internal_set_ffn_first_kernel_clip_max(from._internal_ffn_first_kernel_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_kernel_clip_max = from._internal_ffn_second_kernel_clip_max();
  uint32_t raw_ffn_second_kernel_clip_max;
  memcpy(&raw_ffn_second_kernel_clip_max, &tmp_ffn_second_kernel_clip_max, sizeof(tmp_ffn_second_kernel_clip_max));
  if (raw_ffn_second_kernel_clip_max != 0) {
    _this->_internal_set_ffn_second_kernel_clip_max(from._internal_ffn_second_kernel_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_ln_clip_max = from._internal_self_ln_clip_max();
  uint32_t raw_self_ln_clip_max;
  memcpy(&raw_self_ln_clip_max, &tmp_self_ln_clip_max, sizeof(tmp_self_ln_clip_max));
  if (raw_self_ln_clip_max != 0) {
    _this->_internal_set_self_ln_clip_max(from._internal_self_ln_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_project_output_clip_max = from._internal_self_project_output_clip_max();
  uint32_t raw_self_project_output_clip_max;
  memcpy(&raw_self_project_output_clip_max, &tmp_self_project_output_clip_max, sizeof(tmp_self_project_output_clip_max));
  if (raw_self_project_output_clip_max != 0) {
    _this->_internal_set_self_project_output_clip_max(from._internal_self_project_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_ln_clip_max = from._internal_encdec_ln_clip_max();
  uint32_t raw_encdec_ln_clip_max;
  memcpy(&raw_encdec_ln_clip_max, &tmp_encdec_ln_clip_max, sizeof(tmp_encdec_ln_clip_max));
  if (raw_encdec_ln_clip_max != 0) {
    _this->_internal_set_encdec_ln_clip_max(from._internal_encdec_ln_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_project_output_clip_max = from._internal_encdec_project_output_clip_max();
  uint32_t raw_encdec_project_output_clip_max;
  memcpy(&raw_encdec_project_output_clip_max, &tmp_encdec_project_output_clip_max, sizeof(tmp_encdec_project_output_clip_max));
  if (raw_encdec_project_output_clip_max != 0) {
    _this->_internal_set_encdec_project_output_clip_max(from._internal_encdec_project_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_ln_clip_max = from._internal_ffn_ln_clip_max();
  uint32_t raw_ffn_ln_clip_max;
  memcpy(&raw_ffn_ln_clip_max, &tmp_ffn_ln_clip_max, sizeof(tmp_ffn_ln_clip_max));
  if (raw_ffn_ln_clip_max != 0) {
    _this->_internal_set_ffn_ln_clip_max(from._internal_ffn_ln_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_act_clip_max = from._internal_ffn_first_act_clip_max();
  uint32_t raw_ffn_first_act_clip_max;
  memcpy(&raw_ffn_first_act_clip_max, &tmp_ffn_first_act_clip_max, sizeof(tmp_ffn_first_act_clip_max));
  if (raw_ffn_first_act_clip_max != 0) {
    _this->_internal_set_ffn_first_act_clip_max(from._internal_ffn_first_act_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_qkv_dense_clip_max = from._internal_self_qkv_dense_clip_max();
  uint32_t raw_self_qkv_dense_clip_max;
  memcpy(&raw_self_qkv_dense_clip_max, &tmp_self_qkv_dense_clip_max, sizeof(tmp_self_qkv_dense_clip_max));
  if (raw_self_qkv_dense_clip_max != 0) {
    _this->_internal_set_self_qkv_dense_clip_max(from._internal_self_qkv_dense_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_output_dense_clip_max = from._internal_self_output_dense_clip_max();
  uint32_t raw_self_output_dense_clip_max;
  memcpy(&raw_self_output_dense_clip_max, &tmp_self_output_dense_clip_max, sizeof(tmp_self_output_dense_clip_max));
  if (raw_self_output_dense_clip_max != 0) {
    _this->_internal_set_self_output_dense_clip_max(from._internal_self_output_dense_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_q_dense_clip_max = from._internal_encdec_q_dense_clip_max();
  uint32_t raw_encdec_q_dense_clip_max;
  memcpy(&raw_encdec_q_dense_clip_max, &tmp_encdec_q_dense_clip_max, sizeof(tmp_encdec_q_dense_clip_max));
  if (raw_encdec_q_dense_clip_max != 0) {
    _this->_internal_set_encdec_q_dense_clip_max(from._internal_encdec_q_dense_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_output_dense_clip_max = from._internal_encdec_output_dense_clip_max();
  uint32_t raw_encdec_output_dense_clip_max;
  memcpy(&raw_encdec_output_dense_clip_max, &tmp_encdec_output_dense_clip_max, sizeof(tmp_encdec_output_dense_clip_max));
  if (raw_encdec_output_dense_clip_max != 0) {
    _this->_internal_set_encdec_output_dense_clip_max(from._internal_encdec_output_dense_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_first_output_clip_max = from._internal_ffn_first_output_clip_max();
  uint32_t raw_ffn_first_output_clip_max;
  memcpy(&raw_ffn_first_output_clip_max, &tmp_ffn_first_output_clip_max, sizeof(tmp_ffn_first_output_clip_max));
  if (raw_ffn_first_output_clip_max != 0) {
    _this->_internal_set_ffn_first_output_clip_max(from._internal_ffn_first_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ffn_second_output_clip_max = from._internal_ffn_second_output_clip_max();
  uint32_t raw_ffn_second_output_clip_max;
  memcpy(&raw_ffn_second_output_clip_max, &tmp_ffn_second_output_clip_max, sizeof(tmp_ffn_second_output_clip_max));
  if (raw_ffn_second_output_clip_max != 0) {
    _this->_internal_set_ffn_second_output_clip_max(from._internal_ffn_second_output_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_self_qkv_bias_out_clip_max = from._internal_self_qkv_bias_out_clip_max();
  uint32_t raw_self_qkv_bias_out_clip_max;
  memcpy(&raw_self_qkv_bias_out_clip_max, &tmp_self_qkv_bias_out_clip_max, sizeof(tmp_self_qkv_bias_out_clip_max));
  if (raw_self_qkv_bias_out_clip_max != 0) {
    _this->_internal_set_self_qkv_bias_out_clip_max(from._internal_self_qkv_bias_out_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_q_bias_out_clip_max = from._internal_encdec_q_bias_out_clip_max();
  uint32_t raw_encdec_q_bias_out_clip_max;
  memcpy(&raw_encdec_q_bias_out_clip_max, &tmp_encdec_q_bias_out_clip_max, sizeof(tmp_encdec_q_bias_out_clip_max));
  if (raw_encdec_q_bias_out_clip_max != 0) {
    _this->_internal_set_encdec_q_bias_out_clip_max(from._internal_encdec_q_bias_out_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encdec_kv_bias_out_clip_max = from._internal_encdec_kv_bias_out_clip_max();
  uint32_t raw_encdec_kv_bias_out_clip_max;
  memcpy(&raw_encdec_kv_bias_out_clip_max, &tmp_encdec_kv_bias_out_clip_max, sizeof(tmp_encdec_kv_bias_out_clip_max));
  if (raw_encdec_kv_bias_out_clip_max != 0) {
    _this->_internal_set_encdec_kv_bias_out_clip_max(from._internal_encdec_kv_bias_out_clip_max());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void QuantDecoderLayer::CopyFrom(const QuantDecoderLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:QuantDecoderLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuantDecoderLayer::IsInitialized() const {
  return true;
}

void QuantDecoderLayer::InternalSwap(QuantDecoderLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.self_norm_scale_.InternalSwap(&other->_impl_.self_norm_scale_);
  _impl_.self_norm_bias_.InternalSwap(&other->_impl_.self_norm_bias_);
  _impl_.self_project_bias_qkv_.InternalSwap(&other->_impl_.self_project_bias_qkv_);
  _impl_.self_project_bias_output_.InternalSwap(&other->_impl_.self_project_bias_output_);
  _impl_.encdec_norm_scale_.InternalSwap(&other->_impl_.encdec_norm_scale_);
  _impl_.encdec_norm_bias_.InternalSwap(&other->_impl_.encdec_norm_bias_);
  _impl_.encdec_project_bias_q_.InternalSwap(&other->_impl_.encdec_project_bias_q_);
  _impl_.encdec_project_bias_output_.InternalSwap(&other->_impl_.encdec_project_bias_output_);
  _impl_.ffn_norm_scale_.InternalSwap(&other->_impl_.ffn_norm_scale_);
  _impl_.ffn_norm_bias_.InternalSwap(&other->_impl_.ffn_norm_bias_);
  _impl_.ffn_first_bias_.InternalSwap(&other->_impl_.ffn_first_bias_);
  _impl_.ffn_second_bias_.InternalSwap(&other->_impl_.ffn_second_bias_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.self_project_kernel_qkv_, lhs_arena,
      &other->_impl_.self_project_kernel_qkv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.self_project_kernel_output_, lhs_arena,
      &other->_impl_.self_project_kernel_output_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encdec_project_kernel_q_, lhs_arena,
      &other->_impl_.encdec_project_kernel_q_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encdec_project_kernel_output_, lhs_arena,
      &other->_impl_.encdec_project_kernel_output_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ffn_first_kernel_, lhs_arena,
      &other->_impl_.ffn_first_kernel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ffn_second_kernel_, lhs_arena,
      &other->_impl_.ffn_second_kernel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuantDecoderLayer, _impl_.encdec_kv_bias_out_clip_max_)
      + sizeof(QuantDecoderLayer::_impl_.encdec_kv_bias_out_clip_max_)
      - PROTOBUF_FIELD_OFFSET(QuantDecoderLayer, _impl_.self_project_kernel_qkv_clip_max_)>(
          reinterpret_cast<char*>(&_impl_.self_project_kernel_qkv_clip_max_),
          reinterpret_cast<char*>(&other->_impl_.self_project_kernel_qkv_clip_max_));
}

std::string QuantDecoderLayer::GetTypeName() const {
  return "QuantDecoderLayer";
}


// ===================================================================

class QuantEmbeddingLayer::_Internal {
 public:
};

QuantEmbeddingLayer::QuantEmbeddingLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:QuantEmbeddingLayer)
}
QuantEmbeddingLayer::QuantEmbeddingLayer(const QuantEmbeddingLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  QuantEmbeddingLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_embedding_){from._impl_.position_embedding_}
    , decltype(_impl_.norm_scale_){from._impl_.norm_scale_}
    , decltype(_impl_.norm_bias_){from._impl_.norm_bias_}
    , decltype(_impl_.encode_output_project_bias_kv_){from._impl_.encode_output_project_bias_kv_}
    , decltype(_impl_.shared_bias_){from._impl_.shared_bias_}
    , decltype(_impl_.lang_emb_){from._impl_.lang_emb_}
    , decltype(_impl_.encode_output_project_kernel_kv_clip_max_){from._impl_.encode_output_project_kernel_kv_clip_max_}
    , decltype(_impl_.token_embedding_){}
    , decltype(_impl_.encode_output_project_kernel_kv_){}
    , decltype(_impl_.emb_clip_max_){}
    , decltype(_impl_.output_ln_clip_max_){}
    , decltype(_impl_.logits_clip_max_){}
    , decltype(_impl_.encoder_output_clip_max_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_embedding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_embedding_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_token_embedding().empty()) {
    _this->_impl_.token_embedding_.Set(from._internal_token_embedding(), 
      _this->GetArenaForAllocation());
  }
  _impl_.encode_output_project_kernel_kv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encode_output_project_kernel_kv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_encode_output_project_kernel_kv().empty()) {
    _this->_impl_.encode_output_project_kernel_kv_.Set(from._internal_encode_output_project_kernel_kv(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.emb_clip_max_, &from._impl_.emb_clip_max_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.encoder_output_clip_max_) -
    reinterpret_cast<char*>(&_impl_.emb_clip_max_)) + sizeof(_impl_.encoder_output_clip_max_));
  // @@protoc_insertion_point(copy_constructor:QuantEmbeddingLayer)
}

inline void QuantEmbeddingLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_embedding_){arena}
    , decltype(_impl_.norm_scale_){arena}
    , decltype(_impl_.norm_bias_){arena}
    , decltype(_impl_.encode_output_project_bias_kv_){arena}
    , decltype(_impl_.shared_bias_){arena}
    , decltype(_impl_.lang_emb_){arena}
    , decltype(_impl_.encode_output_project_kernel_kv_clip_max_){arena}
    , decltype(_impl_.token_embedding_){}
    , decltype(_impl_.encode_output_project_kernel_kv_){}
    , decltype(_impl_.emb_clip_max_){0}
    , decltype(_impl_.output_ln_clip_max_){0}
    , decltype(_impl_.logits_clip_max_){0}
    , decltype(_impl_.encoder_output_clip_max_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.token_embedding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_embedding_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encode_output_project_kernel_kv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encode_output_project_kernel_kv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuantEmbeddingLayer::~QuantEmbeddingLayer() {
  // @@protoc_insertion_point(destructor:QuantEmbeddingLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuantEmbeddingLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.position_embedding_.~RepeatedField();
  _impl_.norm_scale_.~RepeatedField();
  _impl_.norm_bias_.~RepeatedField();
  _impl_.encode_output_project_bias_kv_.~RepeatedField();
  _impl_.shared_bias_.~RepeatedField();
  _impl_.lang_emb_.~RepeatedField();
  _impl_.encode_output_project_kernel_kv_clip_max_.~RepeatedField();
  _impl_.token_embedding_.Destroy();
  _impl_.encode_output_project_kernel_kv_.Destroy();
}

void QuantEmbeddingLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuantEmbeddingLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:QuantEmbeddingLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.position_embedding_.Clear();
  _impl_.norm_scale_.Clear();
  _impl_.norm_bias_.Clear();
  _impl_.encode_output_project_bias_kv_.Clear();
  _impl_.shared_bias_.Clear();
  _impl_.lang_emb_.Clear();
  _impl_.encode_output_project_kernel_kv_clip_max_.Clear();
  _impl_.token_embedding_.ClearToEmpty();
  _impl_.encode_output_project_kernel_kv_.ClearToEmpty();
  ::memset(&_impl_.emb_clip_max_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.encoder_output_clip_max_) -
      reinterpret_cast<char*>(&_impl_.emb_clip_max_)) + sizeof(_impl_.encoder_output_clip_max_));
  _internal_metadata_.Clear<std::string>();
}

const char* QuantEmbeddingLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes token_embedding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token_embedding();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float position_embedding = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_position_embedding(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_position_embedding(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float norm_scale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_norm_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 29) {
          _internal_add_norm_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float norm_bias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_norm_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 37) {
          _internal_add_norm_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bytes encode_output_project_kernel_kv = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_encode_output_project_kernel_kv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float encode_output_project_bias_kv = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_encode_output_project_bias_kv(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 53) {
          _internal_add_encode_output_project_bias_kv(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float shared_bias = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_shared_bias(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 61) {
          _internal_add_shared_bias(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float lang_emb = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_lang_emb(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 69) {
          _internal_add_lang_emb(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float emb_clip_max = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.emb_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float encode_output_project_kernel_kv_clip_max = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_encode_output_project_kernel_kv_clip_max(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 85) {
          _internal_add_encode_output_project_kernel_kv_clip_max(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float output_ln_clip_max = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.output_ln_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float logits_clip_max = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.logits_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float encoder_output_clip_max = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _impl_.encoder_output_clip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuantEmbeddingLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:QuantEmbeddingLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes token_embedding = 1;
  if (!this->_internal_token_embedding().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token_embedding(), target);
  }

  // repeated float position_embedding = 2;
  if (this->_internal_position_embedding_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_position_embedding(), target);
  }

  // repeated float norm_scale = 3;
  if (this->_internal_norm_scale_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_norm_scale(), target);
  }

  // repeated float norm_bias = 4;
  if (this->_internal_norm_bias_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_norm_bias(), target);
  }

  // bytes encode_output_project_kernel_kv = 5;
  if (!this->_internal_encode_output_project_kernel_kv().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_encode_output_project_kernel_kv(), target);
  }

  // repeated float encode_output_project_bias_kv = 6;
  if (this->_internal_encode_output_project_bias_kv_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_encode_output_project_bias_kv(), target);
  }

  // repeated float shared_bias = 7;
  if (this->_internal_shared_bias_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_shared_bias(), target);
  }

  // repeated float lang_emb = 8;
  if (this->_internal_lang_emb_size() > 0) {
    target = stream->WriteFixedPacked(8, _internal_lang_emb(), target);
  }

  // float emb_clip_max = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_emb_clip_max = this->_internal_emb_clip_max();
  uint32_t raw_emb_clip_max;
  memcpy(&raw_emb_clip_max, &tmp_emb_clip_max, sizeof(tmp_emb_clip_max));
  if (raw_emb_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_emb_clip_max(), target);
  }

  // repeated float encode_output_project_kernel_kv_clip_max = 10;
  if (this->_internal_encode_output_project_kernel_kv_clip_max_size() > 0) {
    target = stream->WriteFixedPacked(10, _internal_encode_output_project_kernel_kv_clip_max(), target);
  }

  // float output_ln_clip_max = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_output_ln_clip_max = this->_internal_output_ln_clip_max();
  uint32_t raw_output_ln_clip_max;
  memcpy(&raw_output_ln_clip_max, &tmp_output_ln_clip_max, sizeof(tmp_output_ln_clip_max));
  if (raw_output_ln_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_output_ln_clip_max(), target);
  }

  // float logits_clip_max = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_logits_clip_max = this->_internal_logits_clip_max();
  uint32_t raw_logits_clip_max;
  memcpy(&raw_logits_clip_max, &tmp_logits_clip_max, sizeof(tmp_logits_clip_max));
  if (raw_logits_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_logits_clip_max(), target);
  }

  // float encoder_output_clip_max = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encoder_output_clip_max = this->_internal_encoder_output_clip_max();
  uint32_t raw_encoder_output_clip_max;
  memcpy(&raw_encoder_output_clip_max, &tmp_encoder_output_clip_max, sizeof(tmp_encoder_output_clip_max));
  if (raw_encoder_output_clip_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_encoder_output_clip_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:QuantEmbeddingLayer)
  return target;
}

size_t QuantEmbeddingLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:QuantEmbeddingLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float position_embedding = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_position_embedding_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float norm_scale = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_norm_scale_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float norm_bias = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_norm_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float encode_output_project_bias_kv = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_encode_output_project_bias_kv_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float shared_bias = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_shared_bias_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float lang_emb = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_lang_emb_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float encode_output_project_kernel_kv_clip_max = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_encode_output_project_kernel_kv_clip_max_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // bytes token_embedding = 1;
  if (!this->_internal_token_embedding().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_token_embedding());
  }

  // bytes encode_output_project_kernel_kv = 5;
  if (!this->_internal_encode_output_project_kernel_kv().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encode_output_project_kernel_kv());
  }

  // float emb_clip_max = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_emb_clip_max = this->_internal_emb_clip_max();
  uint32_t raw_emb_clip_max;
  memcpy(&raw_emb_clip_max, &tmp_emb_clip_max, sizeof(tmp_emb_clip_max));
  if (raw_emb_clip_max != 0) {
    total_size += 1 + 4;
  }

  // float output_ln_clip_max = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_output_ln_clip_max = this->_internal_output_ln_clip_max();
  uint32_t raw_output_ln_clip_max;
  memcpy(&raw_output_ln_clip_max, &tmp_output_ln_clip_max, sizeof(tmp_output_ln_clip_max));
  if (raw_output_ln_clip_max != 0) {
    total_size += 1 + 4;
  }

  // float logits_clip_max = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_logits_clip_max = this->_internal_logits_clip_max();
  uint32_t raw_logits_clip_max;
  memcpy(&raw_logits_clip_max, &tmp_logits_clip_max, sizeof(tmp_logits_clip_max));
  if (raw_logits_clip_max != 0) {
    total_size += 1 + 4;
  }

  // float encoder_output_clip_max = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encoder_output_clip_max = this->_internal_encoder_output_clip_max();
  uint32_t raw_encoder_output_clip_max;
  memcpy(&raw_encoder_output_clip_max, &tmp_encoder_output_clip_max, sizeof(tmp_encoder_output_clip_max));
  if (raw_encoder_output_clip_max != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QuantEmbeddingLayer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const QuantEmbeddingLayer*>(
      &from));
}

void QuantEmbeddingLayer::MergeFrom(const QuantEmbeddingLayer& from) {
  QuantEmbeddingLayer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:QuantEmbeddingLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.position_embedding_.MergeFrom(from._impl_.position_embedding_);
  _this->_impl_.norm_scale_.MergeFrom(from._impl_.norm_scale_);
  _this->_impl_.norm_bias_.MergeFrom(from._impl_.norm_bias_);
  _this->_impl_.encode_output_project_bias_kv_.MergeFrom(from._impl_.encode_output_project_bias_kv_);
  _this->_impl_.shared_bias_.MergeFrom(from._impl_.shared_bias_);
  _this->_impl_.lang_emb_.MergeFrom(from._impl_.lang_emb_);
  _this->_impl_.encode_output_project_kernel_kv_clip_max_.MergeFrom(from._impl_.encode_output_project_kernel_kv_clip_max_);
  if (!from._internal_token_embedding().empty()) {
    _this->_internal_set_token_embedding(from._internal_token_embedding());
  }
  if (!from._internal_encode_output_project_kernel_kv().empty()) {
    _this->_internal_set_encode_output_project_kernel_kv(from._internal_encode_output_project_kernel_kv());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_emb_clip_max = from._internal_emb_clip_max();
  uint32_t raw_emb_clip_max;
  memcpy(&raw_emb_clip_max, &tmp_emb_clip_max, sizeof(tmp_emb_clip_max));
  if (raw_emb_clip_max != 0) {
    _this->_internal_set_emb_clip_max(from._internal_emb_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_output_ln_clip_max = from._internal_output_ln_clip_max();
  uint32_t raw_output_ln_clip_max;
  memcpy(&raw_output_ln_clip_max, &tmp_output_ln_clip_max, sizeof(tmp_output_ln_clip_max));
  if (raw_output_ln_clip_max != 0) {
    _this->_internal_set_output_ln_clip_max(from._internal_output_ln_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_logits_clip_max = from._internal_logits_clip_max();
  uint32_t raw_logits_clip_max;
  memcpy(&raw_logits_clip_max, &tmp_logits_clip_max, sizeof(tmp_logits_clip_max));
  if (raw_logits_clip_max != 0) {
    _this->_internal_set_logits_clip_max(from._internal_logits_clip_max());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_encoder_output_clip_max = from._internal_encoder_output_clip_max();
  uint32_t raw_encoder_output_clip_max;
  memcpy(&raw_encoder_output_clip_max, &tmp_encoder_output_clip_max, sizeof(tmp_encoder_output_clip_max));
  if (raw_encoder_output_clip_max != 0) {
    _this->_internal_set_encoder_output_clip_max(from._internal_encoder_output_clip_max());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void QuantEmbeddingLayer::CopyFrom(const QuantEmbeddingLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:QuantEmbeddingLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuantEmbeddingLayer::IsInitialized() const {
  return true;
}

void QuantEmbeddingLayer::InternalSwap(QuantEmbeddingLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.position_embedding_.InternalSwap(&other->_impl_.position_embedding_);
  _impl_.norm_scale_.InternalSwap(&other->_impl_.norm_scale_);
  _impl_.norm_bias_.InternalSwap(&other->_impl_.norm_bias_);
  _impl_.encode_output_project_bias_kv_.InternalSwap(&other->_impl_.encode_output_project_bias_kv_);
  _impl_.shared_bias_.InternalSwap(&other->_impl_.shared_bias_);
  _impl_.lang_emb_.InternalSwap(&other->_impl_.lang_emb_);
  _impl_.encode_output_project_kernel_kv_clip_max_.InternalSwap(&other->_impl_.encode_output_project_kernel_kv_clip_max_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_embedding_, lhs_arena,
      &other->_impl_.token_embedding_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encode_output_project_kernel_kv_, lhs_arena,
      &other->_impl_.encode_output_project_kernel_kv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuantEmbeddingLayer, _impl_.encoder_output_clip_max_)
      + sizeof(QuantEmbeddingLayer::_impl_.encoder_output_clip_max_)
      - PROTOBUF_FIELD_OFFSET(QuantEmbeddingLayer, _impl_.emb_clip_max_)>(
          reinterpret_cast<char*>(&_impl_.emb_clip_max_),
          reinterpret_cast<char*>(&other->_impl_.emb_clip_max_));
}

std::string QuantEmbeddingLayer::GetTypeName() const {
  return "QuantEmbeddingLayer";
}


// ===================================================================

class QuantModelConf::_Internal {
 public:
};

QuantModelConf::QuantModelConf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:QuantModelConf)
}
QuantModelConf::QuantModelConf(const QuantModelConf& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  QuantModelConf* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sampling_method_){}
    , decltype(_impl_.head_num_){}
    , decltype(_impl_.beam_size_){}
    , decltype(_impl_.extra_decode_length_){}
    , decltype(_impl_.length_penalty_){}
    , decltype(_impl_.src_padding_id_){}
    , decltype(_impl_.trg_start_id_){}
    , decltype(_impl_.diverse_lambda_){}
    , decltype(_impl_.topp_){}
    , decltype(_impl_.topk_){}
    , decltype(_impl_.trg_end_id_){}
    , decltype(_impl_.is_post_ln_){}
    , decltype(_impl_.no_scale_embedding_){}
    , decltype(_impl_.use_gelu_){}
    , decltype(_impl_.multilg_type_){}
    , decltype(_impl_.n_encoder_stack_){}
    , decltype(_impl_.n_decoder_stack_){}
    , decltype(_impl_.greedy_len_a_){}
    , decltype(_impl_.greedy_len_b_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.sampling_method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sampling_method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sampling_method().empty()) {
    _this->_impl_.sampling_method_.Set(from._internal_sampling_method(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.head_num_, &from._impl_.head_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.greedy_len_b_) -
    reinterpret_cast<char*>(&_impl_.head_num_)) + sizeof(_impl_.greedy_len_b_));
  // @@protoc_insertion_point(copy_constructor:QuantModelConf)
}

inline void QuantModelConf::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sampling_method_){}
    , decltype(_impl_.head_num_){0}
    , decltype(_impl_.beam_size_){0}
    , decltype(_impl_.extra_decode_length_){0}
    , decltype(_impl_.length_penalty_){0}
    , decltype(_impl_.src_padding_id_){0}
    , decltype(_impl_.trg_start_id_){0}
    , decltype(_impl_.diverse_lambda_){0}
    , decltype(_impl_.topp_){0}
    , decltype(_impl_.topk_){0}
    , decltype(_impl_.trg_end_id_){0}
    , decltype(_impl_.is_post_ln_){false}
    , decltype(_impl_.no_scale_embedding_){false}
    , decltype(_impl_.use_gelu_){false}
    , decltype(_impl_.multilg_type_){0}
    , decltype(_impl_.n_encoder_stack_){0}
    , decltype(_impl_.n_decoder_stack_){0}
    , decltype(_impl_.greedy_len_a_){0}
    , decltype(_impl_.greedy_len_b_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sampling_method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sampling_method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuantModelConf::~QuantModelConf() {
  // @@protoc_insertion_point(destructor:QuantModelConf)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuantModelConf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sampling_method_.Destroy();
}

void QuantModelConf::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuantModelConf::Clear() {
// @@protoc_insertion_point(message_clear_start:QuantModelConf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sampling_method_.ClearToEmpty();
  ::memset(&_impl_.head_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.greedy_len_b_) -
      reinterpret_cast<char*>(&_impl_.head_num_)) + sizeof(_impl_.greedy_len_b_));
  _internal_metadata_.Clear<std::string>();
}

const char* QuantModelConf::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 head_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.head_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 beam_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.beam_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 extra_decode_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.extra_decode_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float length_penalty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.length_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 src_padding_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.src_padding_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 trg_start_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.trg_start_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float diverse_lambda = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.diverse_lambda_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string sampling_method = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_sampling_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float topp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.topp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 topk = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.topk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 trg_end_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.trg_end_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_post_ln = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.is_post_ln_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool no_scale_embedding = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.no_scale_embedding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool use_gelu = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.use_gelu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 multilg_type = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.multilg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 n_encoder_stack = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.n_encoder_stack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 n_decoder_stack = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.n_decoder_stack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float greedy_len_a = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _impl_.greedy_len_a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 greedy_len_b = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.greedy_len_b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuantModelConf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:QuantModelConf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 head_num = 1;
  if (this->_internal_head_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_head_num(), target);
  }

  // int32 beam_size = 2;
  if (this->_internal_beam_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_beam_size(), target);
  }

  // int32 extra_decode_length = 3;
  if (this->_internal_extra_decode_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_extra_decode_length(), target);
  }

  // float length_penalty = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_penalty = this->_internal_length_penalty();
  uint32_t raw_length_penalty;
  memcpy(&raw_length_penalty, &tmp_length_penalty, sizeof(tmp_length_penalty));
  if (raw_length_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_length_penalty(), target);
  }

  // int32 src_padding_id = 5;
  if (this->_internal_src_padding_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_src_padding_id(), target);
  }

  // int32 trg_start_id = 6;
  if (this->_internal_trg_start_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_trg_start_id(), target);
  }

  // float diverse_lambda = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_diverse_lambda = this->_internal_diverse_lambda();
  uint32_t raw_diverse_lambda;
  memcpy(&raw_diverse_lambda, &tmp_diverse_lambda, sizeof(tmp_diverse_lambda));
  if (raw_diverse_lambda != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_diverse_lambda(), target);
  }

  // string sampling_method = 8;
  if (!this->_internal_sampling_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sampling_method().data(), static_cast<int>(this->_internal_sampling_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "QuantModelConf.sampling_method");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_sampling_method(), target);
  }

  // float topp = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_topp = this->_internal_topp();
  uint32_t raw_topp;
  memcpy(&raw_topp, &tmp_topp, sizeof(tmp_topp));
  if (raw_topp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_topp(), target);
  }

  // int32 topk = 10;
  if (this->_internal_topk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_topk(), target);
  }

  // int32 trg_end_id = 11;
  if (this->_internal_trg_end_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_trg_end_id(), target);
  }

  // bool is_post_ln = 12;
  if (this->_internal_is_post_ln() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_post_ln(), target);
  }

  // bool no_scale_embedding = 13;
  if (this->_internal_no_scale_embedding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_no_scale_embedding(), target);
  }

  // bool use_gelu = 14;
  if (this->_internal_use_gelu() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_use_gelu(), target);
  }

  // int32 multilg_type = 15;
  if (this->_internal_multilg_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_multilg_type(), target);
  }

  // int32 n_encoder_stack = 16;
  if (this->_internal_n_encoder_stack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_n_encoder_stack(), target);
  }

  // int32 n_decoder_stack = 17;
  if (this->_internal_n_decoder_stack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_n_decoder_stack(), target);
  }

  // float greedy_len_a = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_greedy_len_a = this->_internal_greedy_len_a();
  uint32_t raw_greedy_len_a;
  memcpy(&raw_greedy_len_a, &tmp_greedy_len_a, sizeof(tmp_greedy_len_a));
  if (raw_greedy_len_a != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_greedy_len_a(), target);
  }

  // int32 greedy_len_b = 19;
  if (this->_internal_greedy_len_b() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_greedy_len_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:QuantModelConf)
  return target;
}

size_t QuantModelConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:QuantModelConf)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sampling_method = 8;
  if (!this->_internal_sampling_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sampling_method());
  }

  // int32 head_num = 1;
  if (this->_internal_head_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_head_num());
  }

  // int32 beam_size = 2;
  if (this->_internal_beam_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_beam_size());
  }

  // int32 extra_decode_length = 3;
  if (this->_internal_extra_decode_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_extra_decode_length());
  }

  // float length_penalty = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_penalty = this->_internal_length_penalty();
  uint32_t raw_length_penalty;
  memcpy(&raw_length_penalty, &tmp_length_penalty, sizeof(tmp_length_penalty));
  if (raw_length_penalty != 0) {
    total_size += 1 + 4;
  }

  // int32 src_padding_id = 5;
  if (this->_internal_src_padding_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_src_padding_id());
  }

  // int32 trg_start_id = 6;
  if (this->_internal_trg_start_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_trg_start_id());
  }

  // float diverse_lambda = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_diverse_lambda = this->_internal_diverse_lambda();
  uint32_t raw_diverse_lambda;
  memcpy(&raw_diverse_lambda, &tmp_diverse_lambda, sizeof(tmp_diverse_lambda));
  if (raw_diverse_lambda != 0) {
    total_size += 1 + 4;
  }

  // float topp = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_topp = this->_internal_topp();
  uint32_t raw_topp;
  memcpy(&raw_topp, &tmp_topp, sizeof(tmp_topp));
  if (raw_topp != 0) {
    total_size += 1 + 4;
  }

  // int32 topk = 10;
  if (this->_internal_topk() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_topk());
  }

  // int32 trg_end_id = 11;
  if (this->_internal_trg_end_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_trg_end_id());
  }

  // bool is_post_ln = 12;
  if (this->_internal_is_post_ln() != 0) {
    total_size += 1 + 1;
  }

  // bool no_scale_embedding = 13;
  if (this->_internal_no_scale_embedding() != 0) {
    total_size += 1 + 1;
  }

  // bool use_gelu = 14;
  if (this->_internal_use_gelu() != 0) {
    total_size += 1 + 1;
  }

  // int32 multilg_type = 15;
  if (this->_internal_multilg_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_multilg_type());
  }

  // int32 n_encoder_stack = 16;
  if (this->_internal_n_encoder_stack() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_n_encoder_stack());
  }

  // int32 n_decoder_stack = 17;
  if (this->_internal_n_decoder_stack() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_n_decoder_stack());
  }

  // float greedy_len_a = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_greedy_len_a = this->_internal_greedy_len_a();
  uint32_t raw_greedy_len_a;
  memcpy(&raw_greedy_len_a, &tmp_greedy_len_a, sizeof(tmp_greedy_len_a));
  if (raw_greedy_len_a != 0) {
    total_size += 2 + 4;
  }

  // int32 greedy_len_b = 19;
  if (this->_internal_greedy_len_b() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_greedy_len_b());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QuantModelConf::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const QuantModelConf*>(
      &from));
}

void QuantModelConf::MergeFrom(const QuantModelConf& from) {
  QuantModelConf* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:QuantModelConf)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sampling_method().empty()) {
    _this->_internal_set_sampling_method(from._internal_sampling_method());
  }
  if (from._internal_head_num() != 0) {
    _this->_internal_set_head_num(from._internal_head_num());
  }
  if (from._internal_beam_size() != 0) {
    _this->_internal_set_beam_size(from._internal_beam_size());
  }
  if (from._internal_extra_decode_length() != 0) {
    _this->_internal_set_extra_decode_length(from._internal_extra_decode_length());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_penalty = from._internal_length_penalty();
  uint32_t raw_length_penalty;
  memcpy(&raw_length_penalty, &tmp_length_penalty, sizeof(tmp_length_penalty));
  if (raw_length_penalty != 0) {
    _this->_internal_set_length_penalty(from._internal_length_penalty());
  }
  if (from._internal_src_padding_id() != 0) {
    _this->_internal_set_src_padding_id(from._internal_src_padding_id());
  }
  if (from._internal_trg_start_id() != 0) {
    _this->_internal_set_trg_start_id(from._internal_trg_start_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_diverse_lambda = from._internal_diverse_lambda();
  uint32_t raw_diverse_lambda;
  memcpy(&raw_diverse_lambda, &tmp_diverse_lambda, sizeof(tmp_diverse_lambda));
  if (raw_diverse_lambda != 0) {
    _this->_internal_set_diverse_lambda(from._internal_diverse_lambda());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_topp = from._internal_topp();
  uint32_t raw_topp;
  memcpy(&raw_topp, &tmp_topp, sizeof(tmp_topp));
  if (raw_topp != 0) {
    _this->_internal_set_topp(from._internal_topp());
  }
  if (from._internal_topk() != 0) {
    _this->_internal_set_topk(from._internal_topk());
  }
  if (from._internal_trg_end_id() != 0) {
    _this->_internal_set_trg_end_id(from._internal_trg_end_id());
  }
  if (from._internal_is_post_ln() != 0) {
    _this->_internal_set_is_post_ln(from._internal_is_post_ln());
  }
  if (from._internal_no_scale_embedding() != 0) {
    _this->_internal_set_no_scale_embedding(from._internal_no_scale_embedding());
  }
  if (from._internal_use_gelu() != 0) {
    _this->_internal_set_use_gelu(from._internal_use_gelu());
  }
  if (from._internal_multilg_type() != 0) {
    _this->_internal_set_multilg_type(from._internal_multilg_type());
  }
  if (from._internal_n_encoder_stack() != 0) {
    _this->_internal_set_n_encoder_stack(from._internal_n_encoder_stack());
  }
  if (from._internal_n_decoder_stack() != 0) {
    _this->_internal_set_n_decoder_stack(from._internal_n_decoder_stack());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_greedy_len_a = from._internal_greedy_len_a();
  uint32_t raw_greedy_len_a;
  memcpy(&raw_greedy_len_a, &tmp_greedy_len_a, sizeof(tmp_greedy_len_a));
  if (raw_greedy_len_a != 0) {
    _this->_internal_set_greedy_len_a(from._internal_greedy_len_a());
  }
  if (from._internal_greedy_len_b() != 0) {
    _this->_internal_set_greedy_len_b(from._internal_greedy_len_b());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void QuantModelConf::CopyFrom(const QuantModelConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:QuantModelConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuantModelConf::IsInitialized() const {
  return true;
}

void QuantModelConf::InternalSwap(QuantModelConf* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sampling_method_, lhs_arena,
      &other->_impl_.sampling_method_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuantModelConf, _impl_.greedy_len_b_)
      + sizeof(QuantModelConf::_impl_.greedy_len_b_)
      - PROTOBUF_FIELD_OFFSET(QuantModelConf, _impl_.head_num_)>(
          reinterpret_cast<char*>(&_impl_.head_num_),
          reinterpret_cast<char*>(&other->_impl_.head_num_));
}

std::string QuantModelConf::GetTypeName() const {
  return "QuantModelConf";
}


// ===================================================================

class QuantTransformer::_Internal {
 public:
  static const ::QuantEmbeddingLayer& src_embedding(const QuantTransformer* msg);
  static const ::QuantEmbeddingLayer& trg_embedding(const QuantTransformer* msg);
  static const ::QuantModelConf& model_conf(const QuantTransformer* msg);
};

const ::QuantEmbeddingLayer&
QuantTransformer::_Internal::src_embedding(const QuantTransformer* msg) {
  return *msg->_impl_.src_embedding_;
}
const ::QuantEmbeddingLayer&
QuantTransformer::_Internal::trg_embedding(const QuantTransformer* msg) {
  return *msg->_impl_.trg_embedding_;
}
const ::QuantModelConf&
QuantTransformer::_Internal::model_conf(const QuantTransformer* msg) {
  return *msg->_impl_.model_conf_;
}
QuantTransformer::QuantTransformer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:QuantTransformer)
}
QuantTransformer::QuantTransformer(const QuantTransformer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  QuantTransformer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.encoder_stack_){from._impl_.encoder_stack_}
    , decltype(_impl_.decoder_stack_){from._impl_.decoder_stack_}
    , decltype(_impl_.src_embedding_){nullptr}
    , decltype(_impl_.trg_embedding_){nullptr}
    , decltype(_impl_.model_conf_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_src_embedding()) {
    _this->_impl_.src_embedding_ = new ::QuantEmbeddingLayer(*from._impl_.src_embedding_);
  }
  if (from._internal_has_trg_embedding()) {
    _this->_impl_.trg_embedding_ = new ::QuantEmbeddingLayer(*from._impl_.trg_embedding_);
  }
  if (from._internal_has_model_conf()) {
    _this->_impl_.model_conf_ = new ::QuantModelConf(*from._impl_.model_conf_);
  }
  // @@protoc_insertion_point(copy_constructor:QuantTransformer)
}

inline void QuantTransformer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.encoder_stack_){arena}
    , decltype(_impl_.decoder_stack_){arena}
    , decltype(_impl_.src_embedding_){nullptr}
    , decltype(_impl_.trg_embedding_){nullptr}
    , decltype(_impl_.model_conf_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

QuantTransformer::~QuantTransformer() {
  // @@protoc_insertion_point(destructor:QuantTransformer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuantTransformer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.encoder_stack_.~RepeatedPtrField();
  _impl_.decoder_stack_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.src_embedding_;
  if (this != internal_default_instance()) delete _impl_.trg_embedding_;
  if (this != internal_default_instance()) delete _impl_.model_conf_;
}

void QuantTransformer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuantTransformer::Clear() {
// @@protoc_insertion_point(message_clear_start:QuantTransformer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.encoder_stack_.Clear();
  _impl_.decoder_stack_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.src_embedding_ != nullptr) {
    delete _impl_.src_embedding_;
  }
  _impl_.src_embedding_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.trg_embedding_ != nullptr) {
    delete _impl_.trg_embedding_;
  }
  _impl_.trg_embedding_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.model_conf_ != nullptr) {
    delete _impl_.model_conf_;
  }
  _impl_.model_conf_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* QuantTransformer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .QuantEmbeddingLayer src_embedding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_src_embedding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .QuantEncoderLayer encoder_stack = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_encoder_stack(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .QuantEmbeddingLayer trg_embedding = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_trg_embedding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .QuantDecoderLayer decoder_stack = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_decoder_stack(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .QuantModelConf model_conf = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_conf(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuantTransformer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:QuantTransformer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .QuantEmbeddingLayer src_embedding = 1;
  if (this->_internal_has_src_embedding()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::src_embedding(this),
        _Internal::src_embedding(this).GetCachedSize(), target, stream);
  }

  // repeated .QuantEncoderLayer encoder_stack = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_encoder_stack_size()); i < n; i++) {
    const auto& repfield = this->_internal_encoder_stack(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .QuantEmbeddingLayer trg_embedding = 3;
  if (this->_internal_has_trg_embedding()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::trg_embedding(this),
        _Internal::trg_embedding(this).GetCachedSize(), target, stream);
  }

  // repeated .QuantDecoderLayer decoder_stack = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_decoder_stack_size()); i < n; i++) {
    const auto& repfield = this->_internal_decoder_stack(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .QuantModelConf model_conf = 5;
  if (this->_internal_has_model_conf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::model_conf(this),
        _Internal::model_conf(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:QuantTransformer)
  return target;
}

size_t QuantTransformer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:QuantTransformer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .QuantEncoderLayer encoder_stack = 2;
  total_size += 1UL * this->_internal_encoder_stack_size();
  for (const auto& msg : this->_impl_.encoder_stack_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .QuantDecoderLayer decoder_stack = 4;
  total_size += 1UL * this->_internal_decoder_stack_size();
  for (const auto& msg : this->_impl_.decoder_stack_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .QuantEmbeddingLayer src_embedding = 1;
  if (this->_internal_has_src_embedding()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.src_embedding_);
  }

  // .QuantEmbeddingLayer trg_embedding = 3;
  if (this->_internal_has_trg_embedding()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.trg_embedding_);
  }

  // .QuantModelConf model_conf = 5;
  if (this->_internal_has_model_conf()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.model_conf_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QuantTransformer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const QuantTransformer*>(
      &from));
}

void QuantTransformer::MergeFrom(const QuantTransformer& from) {
  QuantTransformer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:QuantTransformer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.encoder_stack_.MergeFrom(from._impl_.encoder_stack_);
  _this->_impl_.decoder_stack_.MergeFrom(from._impl_.decoder_stack_);
  if (from._internal_has_src_embedding()) {
    _this->_internal_mutable_src_embedding()->::QuantEmbeddingLayer::MergeFrom(
        from._internal_src_embedding());
  }
  if (from._internal_has_trg_embedding()) {
    _this->_internal_mutable_trg_embedding()->::QuantEmbeddingLayer::MergeFrom(
        from._internal_trg_embedding());
  }
  if (from._internal_has_model_conf()) {
    _this->_internal_mutable_model_conf()->::QuantModelConf::MergeFrom(
        from._internal_model_conf());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void QuantTransformer::CopyFrom(const QuantTransformer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:QuantTransformer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuantTransformer::IsInitialized() const {
  return true;
}

void QuantTransformer::InternalSwap(QuantTransformer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.encoder_stack_.InternalSwap(&other->_impl_.encoder_stack_);
  _impl_.decoder_stack_.InternalSwap(&other->_impl_.decoder_stack_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuantTransformer, _impl_.model_conf_)
      + sizeof(QuantTransformer::_impl_.model_conf_)
      - PROTOBUF_FIELD_OFFSET(QuantTransformer, _impl_.src_embedding_)>(
          reinterpret_cast<char*>(&_impl_.src_embedding_),
          reinterpret_cast<char*>(&other->_impl_.src_embedding_));
}

std::string QuantTransformer::GetTypeName() const {
  return "QuantTransformer";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::QuantEncoderLayer*
Arena::CreateMaybeMessage< ::QuantEncoderLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::QuantEncoderLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::QuantDecoderLayer*
Arena::CreateMaybeMessage< ::QuantDecoderLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::QuantDecoderLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::QuantEmbeddingLayer*
Arena::CreateMaybeMessage< ::QuantEmbeddingLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::QuantEmbeddingLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::QuantModelConf*
Arena::CreateMaybeMessage< ::QuantModelConf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::QuantModelConf >(arena);
}
template<> PROTOBUF_NOINLINE ::QuantTransformer*
Arena::CreateMaybeMessage< ::QuantTransformer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::QuantTransformer >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
